<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[面向对象继承方法]]></title>
      <url>%2F2017%2F05%2F01%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[全文字数：5748字，阅读时间：10分钟 继承的概念：通过一定的方式实现让某个类型A获取另外一个类型B的属性和方法。其中类型A称为子类型，类型B称为父类型或超类型。 JavaScript中的继承：Object是所有对象的父类型，所有Javascript中的对象都是直接或间接继承自Object。 继承有两种方式：接口继承和实现继承，在JS中只支持实现继承，实现继承主要依赖原型链来完成。 说明：其他语言中继承通常通过类来实现，JS中没有类的概念（ES6新增了class）。JS中的继承是某个对象继承继承另外一个对象，是基于对象的。 1. 属性拷贝（混入式继承）属性拷贝是浅拷贝，复制引用类型时，只会复制地址，两者会共享同一数据，修改一个会影响另外一个。123456789101112var obj1 = &#123; name : '小明', age : 20, friends : ['小红', '小智']&#125;;var obj2 = &#123;&#125;;//obj2继承obj1的属性for (var k in obj1) &#123; obj2[k] = obj1[k]; //遍历复制属性&#125;obj2.friends.push('小王'); //为子对象添加一个属性//obj1的friends里也会被增加一个小王 在ES6中添加了一个Object.assign()属性123456789var copy = &#123;&#125;;var obj1 = &#123;name : '小明'&#125;;var obj2 = &#123;age : 20&#125;;var obj3 = &#123;friends : ['小红']&#125;;//第一个参数：目标对象，后面的参数：需要拷贝的对象Object.assign(copy, obj1, obj2, obj3);console.log(copy); //输出&#123;name : '小明',age : 20,friends : ['小红']&#125;copy.friends.push('小王');console.log(obj3); //输出&#123;friends : ['小红', '小王']&#125; 同样会影响父对象中的引用类型属性。 2. 原型式继承利用构造函数创建出来的对象可以使用原型对象中的属性和方法 简单的原型式继承：12345function Fun() &#123;&#125;Fun.prototype.des = 'des';var obj = new Fun();console.log(obj.des); //des//构造函数创建的对象可以使用原型的属性方法 复杂一点的原型式继承：12345678910function Fun1() &#123; this.name = '名字';&#125;Fun1.prototype.des = 'des';function Fun2() &#123;&#125;Fun2.prototype = Fun1.prototype;var obj = new Fun2(); //无法获取到name属性//应该修正构造器的指向//Fun2.prototype.constructor = Fun2;console.log(obj.constructor); //默认指向Fun1 问题： 1.原型式继承创建出来的子对象的构造器属性默认指向父构造函数，需要修正consturctor的指向。2.无法获取到父对象构造函数中的属性。 扩展内置对象系统内置的对象(Array、Object等)都可以通过在原型对象上添加属性的方式来让所有子对象拥有这一属性。123456Array.prototype.add = '添加的属性';Array.prototype.addFun = function () &#123; console.log(this.add);&#125;;var arr = [1, 2, 3];arr.addFun(); //添加的属性 不建议使用这种方式，在实际开发中通常是多人合作。如果都扩展内置对象，后期将难以维护，同时也会引发覆盖等安全问题。 安全的扩展内置对象 提供一个自定义构造函数 设置构造函数的原型对象是内置对象的实例 123456789101112//提供一个构造函数function MyArray() &#123;&#125;;//设置构造函数的原型对象为内置对象的实例MyArray.prototype = new Array();MyArray.prototype.des = 'des';MyArray.prototype.logDes = function () &#123; console.log(this.des);&#125;var arr = new MyArray();arr.push('123');arr.logDes(); //desconsole.log(arr); // [123]; 继承来自Array的属性方法 3. 原型链继承实现原型链继承的过程：先提供一个子构造函数和父构造函数，设置子构造函数的原型对象是父构造函数的实例。12345678910111213//设置父构造函数function Person() &#123; this.name = '名字';&#125;//设置父构造函数的原型对象Person.prototype.des = 'des';//设置子构造函数function Student() &#123;&#125;//设置原型链继承Student.prototype = new Person();var stu = new Student();console.log(stu.des); //desconsole.log(stu.name); //名字 原型链继承的注意点在完成原型链继承之后，再进行： 修正构造器属性的指向 设置子构造函数的原型对象的属性和方法，并且不要使用字面量的方式修改子构造函数属性，会产生替换，应使用对象的动态特性设置 原型链继承的问题 无法传递参数给父构造函数 用子构造函数创建多个实例对象时，只会复制引用类型数据地址，会产生共享问题。123456789101112131415161718192021//设置父构造函数function Person(name) &#123; this.name = name; this.friends = ['小明'];&#125;//创建子构造函数function Student(num) &#123; this.num = num;&#125;//设置原型链继承Student.prototype = new Person();//修正构造器指向Student.prototype.constructor = Student;//创建实例对象，无法传递参数到父构造函数var stu1 = new Student('2017');var stu2 = new Student('2018');//设置stu1，也会影响stu2stu1.friends.push = '小红';console.log(stu1); //2017 [小明, 小红]console.log(stu2); //2018 [小明, 小红] Object.creat()方法实现继承作用：创建一个对象，并设置该对象的原型对象为指定对象兼容性：ES51234567891011121314var obj = &#123; name : '名字'&#125;;//o为创建的对象，设置它的原型对象为objvar o = Object.creat(obj);console.log(o.name); //名字//相当于var newObj = &#123; name : '名字'&#125;;//非标写法 var newO=&#123;&#125;; newO.__proto__ = newObj;function Fun()&#123;&#125;;Fun.prototype = newObj;var newO = new Fun(); 4. 借用构造函数（经典继承 | 伪对象继承）call和apply的用法用法：Function.prototype.call/apply()作用：借用其他对象的方法参数输入:第一个参数为需要借参数的对象，之后的为输入的参数不同点：call(对象， 参数1， 参数2…) 参数列表apply(对象， [参数1， 参数2…]) 参数数组 关于this的指向：使用了call或apply方法后，调用的this指向被绑定的对象（第一个参数）。 借用构造函数的用法借用构造函数实现继承解决了无法传递参数给父构造函数的问题12345678910111213function Person(name) &#123; this.name = name;&#125;function Student(num, name) &#123; this.num = num; //通过借用构造函数调用父构造函数的方法实现继承 Person.call(this, name);&#125;//创建不同的实例对象var stu1 = new Student('2017', '小明');var stu2 = new Student('2018', '小红');console.log(stu1); // 2017 小明console.log(stu2); // 2018 小红 5. 组合继承 借用构造函数继承获取实例属性和方法 原型式继承获取原型属性和方法 组合继承 = 借用构造函数继承 + 原型式继承问题：子构造函数原型对象与父构造函数原型对象共享同一数据。 123456789101112131415161718192021222324252627//设置构造函数属性function Person(name) &#123; this.name = name;&#125;//设置原型对象属性方法Person.prototype.des = 'des';Person.prototype.logDes = function () &#123; console.log(this.des);&#125;//创建子构造函数function Student(num, name) &#123; this.num = num; //通过借用构造函数调用父构造函数的方法实现继承 Person.call(this, name);&#125;//利用原型式继承实现继承父构造函数原型对象Student.prototype = Person.prototype;//创建不同的实例对象var stu1 = new Student('2017', '小明');var stu2 = new Student('2018', '小红');console.log(stu1); // 2017 小明console.log(stu2); // 2018 小红//子构造函数与父构造函数共享同一个原型对象Student.prototype.des = 'desStu';//子构造函数原型对象设置了属性，父构造函数原型对象也受到影响var obj = new Person('小王');obj.logDes(); //desStu 6. 深拷贝继承浅拷贝（地址拷贝）1234var copy = &#123;&#125;;for (var k in obj) &#123; copy[k] = obj[k];&#125; 浅拷贝是对值类型属性的复制，遇到引用类型数据时，只能复制其地址 深拷贝（完全拷贝） 创建一个深拷贝的函数，提供2个参数，一个是目标对象，一个是需要拷贝的对象 for in遍历目标对象获取属性，进行判断属性的类型 如果是值类型，直接赋值 如果是引用类型，再调用这个函数，拷贝引用类型里的数据 函数一般是直接调用，不需要修改数据。所以可以当作值类型直接复制地址123456789101112131415161718192021function deepClone(obj, copy) &#123; //被拷贝的对象必须是一个对象 copy = copy || &#123;&#125;; //遍历在目标对象中的所有属性 for (var k in obj) &#123; //判断是否是自身的属性，防止遍历到原型属性 if (obj.hasOwnProperty(k)) &#123; //如果是引用类型的属性（function除外）就要进行深拷贝 if (typeof obj[k] === 'object') &#123; //判断属性是数组还是对象 copy[k] = obj[k].constructor === Array ? [] : &#123;&#125;; //递归进更深一层 deepClone(obj[k], copy[k]); &#125; else &#123; //值类型或者是函数直接复制 copy[k] = obj[k]; &#125; &#125; &#125; return copy;&#125; 在判断对象是否是数组时，我们也可以用到一个方法Array.isArray()括号内输入需要判断的对象，返回值是Boolean类型。但是这个方法是ES5才出来，所以具有兼容问题。 利用深拷贝实现继承 借用构造函数获取实例属性，call和apply 深拷贝获取原型属性 完美的拷贝，独立并且互不影响。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原型链图解]]></title>
      <url>%2F2017%2F04%2F25%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%9B%BE%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[全文字数：1163字，阅读时长：2分钟 原型链的结构 每一个对象都是由构造函数创建出来的。 每一个构造函数都有对应的原型对象。 原型对象也是一个对象，所以原型对象也是由构造函数创建出来的。 以上，形成原型链。 原型链的顶端是Object.prototype，Object.prototype构造出空函数function () {}，空函数构造出Object与Function Object.prototype的构造函数是Object Object.prototype.__proto__ == null 构造函数的也是一个对象，它的构造函数是Function Function也是一个对象，它的构造函数是它自己Function Function的原型对象是空函数function () {} 空函数function () {}的原型对象是Object.prototype Objcet的构造函数是Function Object.__proto__是空函数function () {} Object与Function的关系JavaScript中所有对象(除了Object.prototype)都是Object的实例Function和Object互为对方的实例12345console.log(Function instanceof Function); //trueconsole.log(Function instanceof Object); //trueconsole.log(Object instanceof Function); //trueconsole.log(Object instanceof Object); //trueconsole.log(Object.prototype instanceof Object); //false 原型链属性搜索规则就近原则（屏蔽原则）：通过对象.属性访问属性时，首先会查找自身是否含有该属性，如果没有，会查找其原型对象是否含有该属性，如果有直接返回该属性的值，如果没有就会沿着原型链继续向上查找，直到找到该属性。如果都没有，返回undefined或报错(函数)。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Object 的静态成员]]></title>
      <url>%2F2017%2F04%2F25%2FObject%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[全文字数：1597字，阅读时间：2分钟 静态成员：构造函数对象自己的属性和方法实例成员：直接定义在实例上的属性和方法原型成员：直接定义在原型对象上的属性和方法 所有对象都是Object的实例，所以可以访问Object的静态成员 Object.toString：返回对象的字符串描述信息 object类型返回[object Object] 函数、数组类型返回字符串形式 Number类型可调用该方法，传递参数，表示转换进制 Object.apply/call：调用其他对象的方法 Object.arguments：接收存储函数的实参 Object.assign：属性拷贝 Object.caller：返回一个函数的引用，这个函数调用了当前的函数；另外callee放回正在执行的函数本身的引用，它是arguments的一个属性，常用于递归函数。 Object.constructor：构造器属性，指向构造函数 Object.getPropertyOf：获取原型对象，相当于(.__proto__) Object.create：创建对象并设置原型对象 Object.getOwnPropertyDescriptor：获取实例属性的描述信息 configurable：是否可配置（是否可删除，是否可修改该属性） enumerable：是否可枚举（可用for..in遍历） value：值 writable：是否可重写（修改） Object.defineProperty：设置属性的描述信息 修改已经存在的属性，默认为true 添加新的属性，默认是false 参数：第一个参数为需要配置的对象，第二个参数为该对象需要配置的属性，第三个对象为该属性的描述对象 Object.getOwnPropertyName：获取对象所有实例属性的名字，不包括原型属性。返回一个数组 Object.keys：获取所有对象属性名，不包括原型属性和不可枚举属性 关于Object.getOwnPropertyName与Object.keys的差别 12345678&gt; var obj = &#123;name : '名字', age : 20&#125;;&gt; Object.prototype.des = 'des';&gt; //设置name属性不可枚举&gt; Object.defineProperty(obj, 'name', &#123;enumerable : false&#125;);&gt; //结果都不包含原型属性&gt; console.log(Object.getOwnPropertyName(obj)); //[name, age]&gt; console.log(Object.keys(obj)); //[age]&gt; Object.prevenExtensions：禁止扩展属性（不可以添加属性，可删可改）。可通过Object.isExtensible查询。 Object.seal：密封属性（禁止扩展和删除，禁止修改configurable和enumerable。可以修改属性的值）。可通过Object.isSealed查询。 Object.freeze：冻结属性（不可增删改）。可通过Object.isFrozen查询。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web与网络基础]]></title>
      <url>%2F2017%2F04%2F20%2FWeb%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[全文字数：3365字，阅读时长：8分钟 Web使用一种名为HTTP(HyperText Transfer Protocol，超文本传输协议)的协议作为规范，完成从客户端到服务器端等一系列运作流程。可以说，Web是建立在HTTP协议上通信的。 3项WWW构建技术，分别是：作为页面的文本标记语言的HTML；作为文档传递协议的HTTP；指定文档所在地址的URL。 通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。 TCP/IP 分层管理TCP/IP协议族里最重要的一点就是分层。TCP/IP协议族按层次分别分为一下4层：应用层、传输层、网络层和数据链路层。把TCP/IP层次化是有好处的。比如某个地方需要改变设计时，只要把需要变动的层替换掉就好了。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由行动了。 TCP/IP协议族各层的作用如下。 应用层 应用层决定了向用户提供应用服务时通信的活动。 TCP/IP协议族内预存了各类通用的应用服务。比如，FTP（文件传输协议）和DNS（域名系统）服务就是其中两类。 HTTP协议也处于该层 传输层 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。 在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。 网络层（又名网络互连层） 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输线路。 链路层（又名数据链路曾，网络接口层） 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（网络适配器，即网卡），及光线等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围内。 TCP/IP 通信传输流 以HTTP为例，首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求。 接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据(HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号转发到网络层。 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样以来，发往网络的通信请求就准备齐全了。 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正的接收到由客户端发送过来的HTTP请求。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应首部消去。这种把数据信息把封装起来的做法称为封装（encapsulate）。 IP、TCP 和 DNS负责传输的IP协议按层次分，IP（Internet Protocol）网络协议位于网络层。IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址。IP地址致命了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。 在网络上，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。 无论哪台计算机、哪台网络设备，它们都无法全面掌握互联网中的细节。 确保可靠性的TCP协议按层次分，TCP位于传输层，提供可靠的字节流服务。所谓的字节流服务是指：为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把大数据准确可靠地传给对方。 TCP传输中的三次握手为了准确无误地将数据送达目标出，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN（synchronize）和ACK（acknowledgement）。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表握手结束。 负责域名解析的DNS服务DNS服务是和HTTP协议一样一样位于应用层的协议。它提供域名到IP地址之间的解析服务。用户通常使用主机名或域名来访问对方的计算机，计算机擅长处理数字而不是名称，因此，DNS服务应运而生。 DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。 URI 和 URLURI：统一资源标识符URL：统一资源定位符 URI就是某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。采用HTTP协议时，协议方案就是http。除此之外ftp、file等。 URI 用字符串标识某一互联网资源。而 URL 表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。 绝对URI格式 协议方案名 使用http:或者https:等协议方案名获取访问资源时要指定协议类型。 登录信息（认证） 指定用户名和密码作为从服务器端获取资源时必要的登录信息。可选项。 服务器地址 使用绝对URI必须指定待访问的服务器地址。地址可以是hwong.cn这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名。 服务器端口号 指定服务器连接的网络端口号。可选项，省略则自动使用默认端口号。 带层次的文件路径 指定服务器上的文件路径来定位特指的资源。 查询字符串 针对已指定的的文件路径内的资源，可以使用查询字符串传入任意参数。可选项。 片段标识符 通常可标记出已获取资源中的子资源（文档内的某个位置）。可选项。 参考资料：《图解HTTP》第一章]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构造函数与原型对象]]></title>
      <url>%2F2017%2F04%2F19%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[全文字数：3735字，阅读时长：9分钟 构造函数 函数也可以作为构造函数的参数 构造函数和工厂函数的区别： 构造函数首字母大写 构造函数内部会默认创建新的对象，并且默认返回这个对象 在创建对象的时候，通过new调用构造函数 返回值 构造函数内部没有return，返回默认新创建的对象 如果构造函数内部有return，分两种情况： 返回值类型，忽略该return，返回新创建的对象 返回值是引用类型的数据，会覆盖之前创建的对象，返回该引用类型数据的值1234567function Person(name, age) &#123; this.name = name; this.age = age; //return 'test'; 会忽略该return //return &#123;&#125;; 返回该对象&#125;var p1 = new Person('张三', 20); 实例和实例化使用构造函数创建对象的过程称为实例化，创建出来的这个对象叫做该构造函数的实例。 基本包装类型String、Number、Boolean 可以使用var str = new String(&#39;字符串&#39;)来创建字符串对象，这里typeof str //object var str1 = &#39;字符串&#39;或者var str2 = String(&#39;字符串&#39;)的类型都是string 我们还可以通过 var str = new Object(&#39;字符串&#39;)来创建字符串对象，也可以输入数字或true/false，Object会自动判断是哪种类型。这里typeof str //object 基本数据类型也能有属性或者方法，在内部会进行 创建一个与之对应的对象 利用这个对象访问属性和方法并返回结果 返回结构之后，立即销毁该对象var str = &#39;demo&#39;; console.log(str.length); //4 thisthis指向的是 函数的调用者 或者是 事件的调用者 this -&gt;指向具体的对象函数调用: 作为对象的方法调用 this-&gt;当前的对象 普通函数调用 this-&gt;window 通过new构造函数调用 this-&gt;构造函数内部创建的新对象 使用call / apply调用(函数上下文调用) this-&gt;第一参数 this在事件指令表示事件源this在定时器中表示windows new我们经常利用new运算符去声明新的对象 new运算符接受一个函数F及其参数： new F(arguments…)这一过程分为三步： 创建类的实例。这步是把一个空的对象的__proto__属性设置为F.prototype。 初始化实例。函数F被传入参数并调用，关键字this被设定为该实例。 返回实例，如果没有return，默认返回this引用。 new 运算符的作用是创建一个实例对象。这个对象可以是用户自定义的，也可以是带构造函数的一些系统自带的对象。 new 运算符可以让 this 指向新的对象 所谓“构造函数”，其实就是普通函数内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。为了和普通函数区分， 第一个字母大写 例如：123456789function fun() &#123; alert(this）; //this指向window&#125;fun();function fn() &#123; alert(this）; //this指向fn&#125;new fn(); //添加了new的函数，this指向的是新的对象 私有方法和特权方法私有变量/方法：定义在构造函数内部的变量和方法，私有方法本身是可以访问构造函数内部的所有属性的，即私有属性和共有属性。但是私有方法不可以在构造函数的外部被调用。123456function Fun() &#123; var private = '私有变量'; funciotn privateFun() &#123; console.log('这是一个私有方法'); &#125;&#125; 特权方法：可以当问私有变量和私有函数的实例方法，使用this.来转换。123456789function Fun() &#123; this.name = '名字'; this.showName = funciotn () &#123; //通过this定义一个特权方法 console.log(this.name); &#125;&#125;var obj = new Fun();obj.showName(); //名字 原型对象（prototype） 什么是原型对象？ 在构造函数创建出来的时候，系统会默认创建一个对象和这个构造函数关联，这个对象就称为这个构造函数的原型对象 原型对象的作用？ 使用构造函数创建的对象默认就可以使用原型对象中的属性和方法 怎么访问原型对象？ 构造函数.prototype 对象.__prototype__ 注意：`__prototype__`不是ECMA标准里的属性 怎么设置原型对象？ 原型对象本质也是对象，利用对象的动态特性也可以设置原型对象的属性和方法 使用字面量的方式创建（替换原型） 关于原型对象的替换 替换原型对象之前所创建的对象和替换之后创建的对象，它们的原型对象不是同一个原型对象。（切断） 替换原型对象之后，constructor指向Object，需要在替换时修正构造器的指向 12345678910111213function Person()&#123;&#125; //创建构造函数var p1 = new Person(); //创建对象var obj = &#123; /*修正时需要加一段代码， constructor : Person, 指向原来的原型对象，这样之前创建的对象才能正确使用新的属性方法*/ des : '一段描述'&#125;//替换原型对象Person.prototype = obj;var p2 = new Person();console.log(p1.des); //undefined 替换之前没有des属性console.log(p2.des); //一段描述 原型对象的属性 访问原型对象的属性 对象.属性 构造函数.prototype.属性 属性的访问原则 就近原则： 使用对象.属性访问属性的时候，首先会去找自己身上的属性（实例属性），如果找到就返回该值，如果没有，会去该对象构造函数原型对象上找是否有这个属性（原型属性）。如果都没有，返回undefined或报错(函数)。 设置原型对象的属性 通过构造函数.prototype.属性来设置换着替换原型对象属性 如果属性是引用类型的数据，可以通过实例对象.引用对象.属性的方式修改 关于实例对象中的属性与原型对象中的属性虽然能通过实例对象访问原型对象中的值，但不能通过实例对象重写原型中的值，当为实例对象添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，换句话说，添加的这个属性只会阻止我们访问原型中的那个属性，但不会对原型中属性产生任何影响。不过使用delete操作符可以完全删除实例属性，从而让我们可以重新访问原型中的属性。 属性存在的检测 for..in： 判断对象中是否存在指定的属性。既可以检测实例属性也可以检测原型属性。 hasOwnProperty()方法 ：判断对象中是否存在指定的实例对象中。 补充：对象(Object)数据类型 &gt; 对象就是带有**属性**和**方法**的*数据类型* 例如 `Array`、`Date`等，我们最常用的`Function`也是一个对象，虽然 1typeof function()&#123;&#125;; //"function" 但是Function实例和其他类型的实例没有什么区别，都是对象，只不过`typeof`操作符对其做了特殊处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象基本介绍与创建对象]]></title>
      <url>%2F2017%2F04%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[全文字数：1888字，阅读时长：4分钟 对象（Object）是什么？ 在软件系统中，对象具有唯一的标识符，对象包括属性（Properties）和方法（Methods），属性就是需要记忆的信息，方法就是对象能够提供的服务。在面向对象（Object Oriented）的软件中，对象（Object）是某一个类（Class）的实例（Instance）。 —— 维基百科 面向对象语言的特点：有类(class)的概念，如C++、Java。Javascript没有类的概念，基于原型，支持面向对象。 基本数据类型 string、 number、 boolean、 null、 undefined null、undefined分别表示没有声明和声明后没有初始化的变量、对象，是两个简单的值，其余三个有对应的包装对象Number、Boolean、String 面向对象三大特性 封装 封装就是把过程和数据封闭起来，对数据的访问只能通过开放的接口 作用：方便维护，提高代码的复用性，信息隐蔽 继承 子类对象继成使用父亲的属性和方法 多态 多态是指两个或多个属于不同类的对象，对于同一个消息（方法调用）做出不同响应的方式 Javascript天生就具备多态的特性（弱类型语言） 创建对象 字面量式声明对象 使用场景：只需要简单的创建几个对象 123var obj = &#123; name : 'object'&#125;; 问题：在创建同类型的代码时存在大量重复代码 使用内置的构造函数 系统内置的构造函数: Object、Array、Date、Function等 123var obj = new Object();obj.name = 'object';//等价于 var obj = &#123;&#125;; 问题：复用性不好，存在大量冗余重复代码，与字面量方式类似 简单的工厂的函数 封装：把固定部分写在函数体中，不同的作为函数的参数传递进去 1234567891011//// 01提供函数(工厂函数)封装对象的创建过程function creat(name) &#123; //创建一个空的对象 var obj = new Object(); //设置属性和方法 obj.name = name; //返回对象 return obj;&#125;//创建对象var newObj = creat('objName'); 问题：创建不同类型对象时，无法识别对象 自定义构造函数创建对象 提供一个构造函数 通过this设置属性和方法 使用new构造函数创建对象 12345678910111213function Person(name, age) &#123; /* 默认会创建一个新的对象 var obj = new Object(); 默认会把新创建的对象赋值给this this = obj; */ this.name = name; this.age = age; /*默认会返回新创建的对象 return this;*/&#125;var p1 = new Person('张三', 20); 问题：破坏封装性，结构性不好，全局变量污染。创建多个对象时，内部属性方法一样，每次都会开辟一块新的内存空间，造成浪费解决办法：通过原型属性和方法 判断对象的类型 instanceof ：判断某一变量是否为一个对象的实例 用法：判断a是否是A的一个实例，a instanceof A；返回boolean isPropertyOf：判断一个对象是否是指定对象的原型对象 用法：判断object是否是obj的原型对象，object.isPropertyOf(obj); 返回boolean constructor ：构造器属性，获取对象是由哪一个构造函数所创建的 用法：获得实例对象a的构造函数 a.constructor; 返回a的构造函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[值类型与引用类型及在内存中的存储]]></title>
      <url>%2F2017%2F04%2F05%2F%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[全文字数：3450字，阅读时长：8分钟 Part1 值类型与引用类型值类型与引用类型的定义 值类型（基本类型） 定义：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。 5种基本数据类型：string、number 、boolean、null、undefined。 引用类型 定义：存放在堆内存中的对象，变量保存的实际是一个指针，当我们需要访问引用类型时，存放在栈内存中的指针会将我们指向堆内存的数据。每块空间大小不一样，根据情况进行特定的分配。 常见的引用类型有：Array、Object、Function 值类型与引用类型的存储（传值与传址） 值类型的赋值：把右边存储的信息（具体数据）复制一份给左边的变量。 特点：值类型赋值只是简单的数据复制，互相不影响，是独立的。 12345var a = 10;var b = a; //具体数据的复制，复制之后a,b相互独立互不影响b = 1;console.log(a); //10console.log(b); //1 引用类型的赋值：把右边存储的信息（指向具体数据的地址）复制一份给左边的变量。 特点：共享同一份数据，修改其中一个对象属性的值也会影响另一个。 1234567var obj1 = &#123; num : 10 &#125;;var obj2 = obj1; //数据地址的复制，两个对象指向同一份数据，共享同一份数据。obj2.num = 1;console.log(obj1.num); //1 修改obj2的属性也会影响obj1console.log(obj2.num); //1 值类型与引用类型在函数中的应用 在函数中的参数有两种，一种是实参，就是实际的参数。还有一种是形参，形式参数，占位用的，函数调用之前是没有值的。 函数的调用：默认会把实参赋值给形参。 值类型作为函数的参数(值传递) 形参与实参相互独立，没有影响 12345678var num = 10;function fn(n) &#123;//默认会执行一步 n = num； n = 10; console.log(n); //10&#125;fn(num); //函数的调用console.log(num); //20 值传递时，形参实参互不影响 引用类型做为函数的参数(指针传递) 实参形参共享同一份数据，修改一个对象的值也会对另外一个对象产生影响 123456789var obj = &#123;num : 10&#125;; //定义一个对象function fn(object) &#123;//默认进行 object = obj； 此时进行了地址的传递 object.num = 1； //修改了一个源数据，所有指向改数据的对象的属性都进行了更改 object = &#123;other : others&#125;; //object新建一块内存空间，指针指向新建的空间 console.log(object.num); //undefined 新建的空间内部已经没有num属性&#125;fn(obj); //调用函数console.log(obj.num); //1 被object更改了属性 Part2 堆栈的概念堆栈的定义 堆（heap） 动态分配内存，大小不定，不会自动释放存储空间，堆中存储复杂类型数据 栈（stack） 自动分配内存恐怖关键，系统自动释放，栈中存储简单类型数据 栈是一中特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。 后进先出（Last in First out）,简称LIFO线性表 数据在堆栈中的表示JavaScript在内存中是如何表示的呢？我们可以通过以下例子来了解值类型和引用类型在内存中是如何存储的。 123456789101112var zs = &#123; name : 'zs', age : 10, sex : '男', dog : dog, //指向dog对象 run : function () &#123;&#125; //指向run函数&#125;;var dog = &#123; name : '旺财', age : 10, run : function () &#123;&#125; //指向run函数&#125;; 以上代码可以描述为图示的关系： Part3 深拷贝与浅拷贝浅拷贝在定义一个对象或数组的时候，变量在栈中只是存储了一个地址（指针），当我们复制该对象或数组的时候，复制的值也是该地址。在访问属性的时候，还是会通过复制的地址回溯到原来对象或数组指向的内存中。即两者共享了同一内存空间。修改一个对象的属性，另一个对象也会受到影响。1234567function Copy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c; &#125; 深拷贝当我们不希望复制后的对象还与原对象共享同一数据，两者独立时，我们可以使用深拷贝来解决，通过递归的方法，把原对象中的属性方法都遍历给新的对象。这样，两个对象的属性会存储在堆中的不同内存空间。123456789101112131415161718192021function deepClone(obj, copy) &#123; //被拷贝的对象必须是一个对象 copy = copy || &#123;&#125;; //遍历在目标对象中的所有属性 for (var k in obj) &#123; //判断是否是自身的属性，防止遍历到原型属性 if (obj.hasOwnProperty(k)) &#123; //如果是引用类型的属性（function除外）就要进行深拷贝 if (typeof obj[k] === 'object') &#123; //判断属性是数组还是对象 copy[k] = obj[k].constructor === Array ? [] : &#123;&#125;; //递归进更深一层 deepClone(obj[k], copy[k]); &#125; else &#123; //值类型或者是函数直接复制 copy[k] = obj[k]; &#125; &#125; &#125; return copy;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取DOM元素事件位置信息的常用方法]]></title>
      <url>%2F2017%2F04%2F02%2Fclient%E3%80%81offset%E3%80%81screen%E3%80%81page%E3%80%81scroll%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
      <content type="text"><![CDATA[全文字数：3630字，阅读时长：8分钟 在JavaScript的DOM操作中，我们经常需要获取元素或事件的宽高及定位信息。因此我们就需要用到一些属性来得到我们想要的信息。 Part1 client、scroll、offset元素属性的定义在w3c的官方文档里，我们可以看到这几个属性都归类在HTML DOM元素对象的属性方法中，适用于所有HTML元素，都是只读属性。 12345678element.clientHeight //在页面上返回内容的可视高度（不包括边框，边距或滚动条）element.clientLeft //元素的左边框的宽度,若左边出现了垂直滚动条，也包含滚动条的宽度element.offsetHeight //返回元素的高度，包括边框和填充，但不是边距element.offsetLeft //获取边框相对于具有定位属性的父对象的左边距element.scrollHeight //返回元素的整体高度（包括带滚动条的隐蔽的地方）element.scrollLeft //滚动条卷去隐藏的距离 clientHeight、scrollHeight、offsetHeight的比较clientclientHeight：可见区域的宽度，不包括boder的宽度，如果区域内带有滚动条，还应该减去横向滚动条不可用的高度，正常的是17px，其实就是滚动条的可滚动的部分了，其实clientHeight与height的高度差不多，如果不带滚动条的话他们的值都是一样的，如果带有滚动条的话就会比height值少17px；火狐与IE下均为一致。注意，对于类型&lt;i&gt;,&lt;code&gt;和&lt;span&gt;这些内联元素,clientWidth和clientHeight总是返回0。 scrollscrollHeight：同样不包含border,由height与padding相加。若包含滚动条，scrollHeight就是滚动条可滚动的距离。（height与padding相加在减去滚动条的高度，默认为17px）。直观的说法就是元素的内容区域加上它的内边距再加上任何溢出内容的尺寸。当内容正好和内容区域匹配而没有溢出时，这些属性与clientWidth和clientHeight是相等的。但当溢出时，它们就包含溢出的内容，返回值比clientWidth和clientHeight要大。 offsetoffsetHeight：元素的offsetHeightw值包括该元素的边框,元素的垂直内边距,元素的水平滚动条(若出现水平滚动条),以及元素的样式高度。实际值为height + padding + border。 测试代码123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试代码&lt;/title&gt; &lt;style&gt; div&#123; overflow: scroll; /*设置滚动条*/ position: absolute; left: 1500px; width: 300px; height: 300px; border: 5px solid #000; padding: 10px; margin: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; console.log('clientWidth: '+ div.clientWidth); //320 padding+width 有滚动条时 303 padding+width-scroll(默认17px) console.log('clientLeft: '+ div.clientLeft); //5 边框的宽度，有滚动条就加滚动条宽度 console.log('offsetWidth: '+ div.offsetWidth); //330 boder + padding + width console.log('offsetLeft: '+ div.offsetLeft); //1520 获取边框相对于具有定位属性的父对象的左边距 console.log('scrollWidth: ' + div.scrollWidth); //320 padding + width 有滚动条时 303 padding+width-scrollWidth(默认17px) console.log('scrollLeft: ' + div.scrollLeft); //0 滚动条卷去的部分&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Part2 offset、client、screen、page在DOM事件中的定义在文档中，以上4个属性都归类在DOM Event中，属于事件状态，需要与函数结合起来使用，函数不会在事件发生前执行。常见的事件有鼠标点击、键盘按下等，事件发生后，我们就能检测相应的属性。 screenscreenX:鼠标位置相对于用户屏幕水平偏移量，此时的参照点也就是原点是屏幕的左上角。 clientclientX:跟screenX相比就是将参照点改成了浏览器内容区域的左上角，该参照点会随之滚动条的移动而移动，也就是说，他计算left或top时直接忽略了滚动条的高和宽，它的参考点是浏览器可见区域的左上角，而不是页面本身的body左上角原点，计算数值和滚动条是否滚动没有关系，只是绝对的计算鼠标点距离浏览器内容区域的左上角的距离，忽略了滚动条的存在。 pagepageX：参照点是页面本身的body原点，而不是浏览器内容区域左上角，它计算的值不会随着滚动条而变动，它在计算时其实是以body左上角原点（即页面本身的左上角，而不是浏览器可见区域的左上角）为参考点计算的，这个相当于已经把滚动条滚过的高或宽计算在内了，所以无论滚动条是否滚动，他都是一样的距离值。 pageX = clientX + ScrollLeft(滚动条滚过的水平距离)pageY = clientY + ScrollTop(滚动条滚过的垂直距离) offsetoffsetX：offsetX 表示鼠标指针位置相对于触发事件的对象的 x 坐标。不包含边框，所以可以为负值。 总结在实际开发中，我们经常要使用以上的方法来获得我们需要的值。首先，我们应该注意每一种属性的区别，了解他们是如何计算出来的，不至于在开发中张冠李戴，出现错误。其次，以上各种属性在不同浏览器中也有兼容问题，也是我们必须要要小心的地方，因为你可能写对了名字，但是在这个浏览器中无效，那也是白忙活一场。所以，在开发时，应尽量避免出现这些问题，多进行验证，这样才能保证代码的正确性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[offset类属性与style类属性的区别]]></title>
      <url>%2F2017%2F03%2F21%2Foffset%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8Estyle%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[全文字数：1115字，阅读时长：3分钟 offset类属性与style类属性的区别在JavaScript DOM操作中，有两个属性可以获取元素的width属性，但是两者也有很大的不同 style类属性 必须要是行内元素才能获取到，当元素的宽高写在CSS中时，无法获取 获取到的是String，带px 可读写 若没有设置left，style.left返回空字符串 “ “ offset类属性 获取元素的实际存在的宽高，不管是在行内还是页内 获取到的是Number 只可读 offsetWidth(Height)与style.width(height) style中的width与height 不包含边框及内边距 offsetWidth与offsetHeight 获得的数值是元素的宽度+内边距+边框相加 offsetLeft(Top)与style.left(top) style中的left与top 获取的是相对于父对象（具有定位属性 position:relative）的左边距 offsetLeft与Top 获取的是相对于父对象的左边距 offsetParrent与parrentNode offsetParrent 定位定到具有定位属性父元素的 parrentNode 直接定到直系父元素]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的数据类型转换]]></title>
      <url>%2F2017%2F03%2F14%2FJavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[全文字数：2037字，阅读时长：5分钟 Part1 数字转换成字符串1.1 使用JS内部方法进行转换 parseInt 可以将一个字符串型整数进行转换. parseInt提取数字注意点. 第一个字母必须是数字,如果不是数字则显示NaN parseFloat 可以将一个字符串型的浮点数进行转换 因为JS是弱类型语言, 不管是int还是float都是Number. 1.2 直接使用Number对象进行包裹12var a = "10";console.log(Number(a)); 1.3 参与数学计算(加法除外) 加法会将字符串进行拼接 乘法、除法、模运算(取余)都可以将字符串类型变成Number类型. Part2 数字转换成字符串2.1 方法一:直接使用字符串方法 使用数学运算(仅限于加法) 1234var a = 123;console.log(a + "");console.log(typeof (a+ ""));//结果转换成String 使用字符串方法 1234var a = 123;console.log(a.toString());console.log(typeof (a.toString()));//结果转换成String 直接使用String进行包裹 1234var a = 123;console.log(String(a));console.log(typeof (String(a)));//结果转换成String 2.2 方法二:使用小数化方法进行转换 保留三位小数,四舍五入 1234var a = 123.123;console.log(a.toFixed(3));console.log(typeof (a.toFixed(3)));//结果转换成String toFixed: 把数字转换为字符串，结果的小数点后有指定位数的数字。 以指数形式保存 1234var a = 123.123;console.log(a.toExponential(3));console.log(typeof (a.toExponential(3)));//结果转换成String toExponential: 把对象的值转换为指数计数法。 保留三位有效数字,四舍五入 1234var a = 123.123;console.log(a.toPrecision(3));console.log(typeof (a.toPrecision(3)));//结果转换成String toPrecision: 把数字格式化为指定的长度。 Part3 Boolean类型转换 非零即为True 即使是负数 3.1 布尔类型转数字12var isTrue = true;console.log(Number(isTrue)); //1 3.2 布尔类型转字符串12var isTrue = true;console.log(String(isTrue)); //1 3.3 数字转布尔12var age = 13;console.log(Boolean(age)); 3.4 字符串转布尔12345var name = "张三"; //truevar name = " "; //falsevar name = null; //falseconsole.log(Boolean(age));//字符串转布尔需保证有值才为true. 3.5 其他类型转布尔123456var a = NaN; //falsevar b = Infinity; //true,无穷大,非零即为真var c = undefined; //falseconsole.log(Boolean(a));console.log(Boolean(b));console.log(Boolean(c));]]></content>
    </entry>

    
  
  
</search>
