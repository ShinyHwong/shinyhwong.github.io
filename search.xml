<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[模版引擎 nunjucks]]></title>
      <url>%2F%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E%20nunjucks.html</url>
      <content type="text"><![CDATA[在 js 中，通过 nunjucks.render(模板名 name , 数据 context) 来得到页面数据，可通过 res.end(数据) 将页面传递出去。 注释 注释 #&#125;```123- 变量 ```&#123;&#123; name &#125;&#125; if 判断 1234567&#123;% if 条件1 %&#125; 执行内容1;&#123;% elif 条件2 %&#125; 执行内容2;&#123;% else %&#125; 执行内容3;&#123;% endif %&#125; for 循环for 可以遍历数组和对象 12345&lt;ul&gt; &#123;% for item in items %&#125; &lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; macro 宏命令 12345678&#123;#定义了一个名为user的方法， 传入参数name#&#125; &#123;% macro user(name) %&#125; &lt;h1&gt; &#123;&#123; name &#125;&#125; &lt;/h1&gt; &#123;% endmacro %&#125;&#123;#调用函数#&#125; &#123;&#123;user('小明')&#125;&#125; &#123;&#123;user('小红')&#125;&#125; 模版继承观察各种网站可以发现，网站的结构实际上是类似的，头部、尾部都是固定格式，只有中间页面部分内容不同。如果每个模板都重复头尾，一旦要修改头部或尾部，那就需要改动所有模板。更好的方式是使用继承。先定义一个基本的网页框架 base.html 1234567891011&#123;% block header %&#125; &lt;h3&gt;Unnamed&lt;/h3&gt; &#123;% endblock %&#125;&#123;% block body %&#125; &lt;div&gt;No body&lt;/div&gt; &#123;% endblock %&#125;&#123;% block footer %&#125; &lt;div&gt;copyright&lt;/div&gt; &#123;% endblock %&#125; base.html 定义了三个可编辑的块，分别是 header、body、footer。子模版也可以有选择地对块重新定义。 12345&#123;% extends 'base.html' %&#125;&#123;% block header %&#125;&lt;h1&gt;&#123;&#123; header &#125;&#125;&lt;/h1&gt;&#123;% endblock %&#125;&#123;% block body %&#125;&lt;p&gt;&#123;&#123; body &#125;&#125;&lt;/p&gt;&#123;% endblock %&#125; 然后对子模版进行渲染： 1234console.log(env.render('extend.html', &#123; header: 'Hello', body: 'bla bla bla...'&#125;)); 输出 HTML 如下： 123&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;bla bla bla...&lt;/p&gt;&lt;div&gt;copyright&lt;/div&gt; &lt;-- footer没有重定义，所以仍使用父模板的内容 includeinclude 可引入其他的模板 12&#123;#复制 index.njk 的内容#&#125;&#123;% include "index.njk" %&#125; importuser.njk: 123&#123;% macro create(content) %&#125; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&#123;% endmacro %&#125; 通过导入 user.njk，相当于将其赋值给 user const user = require(‘user’); 12&#123;% import 'user.njk' as user %&#125; &#123;&#123;user.create('内容')&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工厂模式与备忘录模式实例详解]]></title>
      <url>%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3.html</url>
      <content type="text"><![CDATA[工厂模式适用于大批量创建同类型的对象，通过同一个接口创建对象，根据传入的参数不同从而创建不同内容的对象，让这个接口由子类决定实例化哪一个类。优点：解决了多个类似对象声明的问题，易于维护和扩展，稳定性好。推荐场景：1. 对象的构建十分复杂。 2. 需要依赖具体环境创建不同实例。 3. 处理大量具有相同属性的小对象。 实施过程： 提供父构造函数 设置父构造函数的原型对象 定制不同对象上的差异化属性(设置子构造函数–&gt;父构造函数的静态方法) 在父构造函数上添加静态工厂方法 判断是否支持生产 设置子构造函数（父构造函数的静态方法）的原型对象 修正构造器属性 返回利用子构造函数创建的实例对象 使用父构造函数的静态工厂方法创建指定的对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//1. 提供父构造函数function CarFactory() &#123;&#125;//2. 设置父构造函数原型对象（共同属性）CarFactory.prototype = &#123; rank: this.num, bandName: function () &#123; console.log(this.carBand) &#125;, country: function () &#123; console.log(this.country) &#125;&#125;;//3. 定制不同对象差异化属性CarFactory.benz = function () &#123; this.carBand = 'benz'; this.country = 'Germany'; this.num = 1;&#125;;CarFactory.audi = function () &#123; this.carBand = 'audi'; this.country = 'Germany'; this.num = 2;&#125;;CarFactory.bmw = function () &#123; this.carBand = 'bmw'; this.country = 'Germany'; this.num = 3;&#125;;//4. 在父构造函数上添加静态工厂方法CarFactory.product = function (band) &#123; //容错处理，判断能否生产 if (typeof CarFactory[band] !== 'function') &#123; throw '目前不支持生产'; //抛出异常 &#125; //设置子构造函数的原型属性为父构造函数的实例，完成原型链继承 CarFactory[band].prototype = new CarFactory(); //修正构造器属性 CarFactory[band].prototype.constructor = CarFactory[band]; //让父构造函数的静态工厂方法返回子构造函数的的实例对象 return new CarFactory[band]();&#125;;//5. 利用父构造函数的静态方法创建对象var benz = CarFactory.product('benz');console.log(benz); //&#123;carBand: "benz", country: "Germany", num: 1&#125;var audi = CarFactory.product('audi');console.log(audi); //&#123;carBand: "audi", country: "Germany", num: 2&#125;var volkswagen = CarFactory.product('volkswagen');console.log(volkswagen); //不支持生产，抛出异常 备忘模式(函数结果缓存)特定场景：当某个函数需要接受参数，可能会反复计算并且在函数内部需要进行耗时并且大量的逻辑处理才能得到结果时。我们可以把计算结果保存包函数对象中。计算时，先去缓存中查找，没有再计算。 函数是对象，可以在函数上面添加属性和方法 函数的参数作为key，结果作为value。 步骤： 1. 提供一个缓存对象`cache`（key-value） 2. 获取传入的参数 3. 在缓存对象`cache`中查找是否有结果 4. 有，就返回 5. 没有，执行函数得到结果保存到`cache`中并返回结果。 1234567891011121314151617var memento = function (param) &#123; //初次运行建立缓存 if (typeof memento.cache === 'undefined') &#123; memento.cache = &#123;&#125;; &#125; //如果有缓存就返回存储的结果 if (memento.cache[param] !== undefined) &#123; return memento.cache[param]; &#125; //没有就进行计算得到结果存储 var result = ''; //初始化计算结果 //复杂计算，结果保存到result memento.cache[param] = result; //存储结果 return result;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单例模式实例详解]]></title>
      <url>%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3.html</url>
      <content type="text"><![CDATA[保证一个特定的类只有一个实例（并且永远是同一个）在JavaScript中，只有对象没有类，要实现单例模式也有多种方法。 最简单的方式：通过字面量来创建对象，因为在JS中对象之间永远不可能相等，除非它们是同一个对象使用字面量创建的对象总是唯一的。 实现单例模式的的几种途径 在代码中提供一个全局变量来存储创建出来的实例。缺点：该全局变量可能会被轻易的修改和覆盖 尝试在构造函数的静态成员中缓存实例属性。缺点：函数的静态属性在外部可以直接修改，容易导致实例对象的丢失。 将实例对象包装在闭包中，安全性好，无法轻易修改。缺点：有额外的闭包开销。 全局变量方法1234567891011121314151617181920//提供全局变量，使用全局变量来接收内部创建出来的实例对象（this）var instance; //提供构造函数function Singleton () &#123; //判断是否已经创建存在过 if (instance) &#123; //如果创建过直接返回 return instance; &#125; //默认把实例对象赋值给this再传给全局变量instance instance = this; //设置实例属性方法 this.property = '设置属性'; this.fun = function() &#123;'设置方法'&#125;; &#125;var obj1 = new Singleton();var obj2 = new Singleton();//两个对象存储数据的地址一样，实际就是一个对象console.log(obj1 === obj2); //true 但是上述方法有一个明显的问题，全局变量instance容易被修改，造成之后创建的实例指向错误的数据。 改进：通过即使调用函数，把instance封闭在里面。123456789101112131415//声明构造函数var Singleton;(function () &#123; //内部声明instance var instance; Singleton = function () &#123; if (instance) &#123; //如果创建过直接返回 return instance; &#125; instance = this; this.property = '设置属性'; this.fun = function() &#123;'设置方法'&#125;; &#125;&#125;)(); 这样只能修改构造函数名称，但是修改了的话浏览器会报错提示我们Singleton is not a constructor，可以很快排错。 构造函数静态属性方法通过把instance设置为构造函数Singleton的静态属性，在一定程度上可以防止被修改。但是通过Singleton.instance还是可以修改到。12345678function Singleton () &#123; if (Singleton.instance) &#123; return Singleton.instance; &#125; Singleton.instance = this; this.property = '设置属性'; this.fun = function() &#123;'设置方法'&#125;; &#125; 惰性函数方法实现思路：在构造函数内部声明一个私有变量instance，利用惰性函数执行过一次后自我更新的特性可以直接返回instance。 问题：由于惰性函数的自我更新，导致构造函数指向新的对象 在构造函数更新过一次后，新的构造函数创建出来的实例的constructor属性还是跟第一次创建出来的实例一样，指向更新前的构造函数。并且创建对象以后设置的原型对象和单例对象不是同一个（由于更新之后，新构造函数的原型对象与旧构造函数的原型对象不是同一个），导致创建对象后设置到原型对象的属性和方法无法访问。 改进方法：利用原型链继承，将新构造函数原型对象设置为旧构造函数的实例。同时用新构造函数创建实例赋值给instance，并修正instance构造器属性指向。 步骤： 1. 提供一个构造函数 2. 在构造函数内部提供一个私有变量 3. 利用惰性函数实现构造函数的自我更新(直接返回instance) 4. 设置新构造函数的原型对象是旧构造函数的一个实例 5. 使用新构造函数创建对象并赋值给instance 6. 修正构造器属性指向更新后的构造函数 7. 使用instance设置属性和方法 8. 返回instance 1234567891011121314151617181920212223242526//提供单例构造函数function Singleton () &#123; /*系统在新建Singleton的实例对象时，会有如下默认操作 var 实例对象 this = 实力对象 所以在第一次执行时，this就代表最开始这个构造函数的实例对象*/ //提供私有变量 var instance; //惰性函数执行一次后自我更新 Singleton = function () &#123; return instance; &#125;; //自我更新后，Singleton代表新构造函数，this指向旧构造函数的实例 //原型链继承，实现原型属性访问修改 Singleton.prototype = this; //设置私有变量为新构造函数的实例对象 instance = new Singleton(); //修正构造器属性指向更新后的构造函数 instance.constructor = Singleton; //设置属性方法 instance.property = '设置属性'; instance.fun = function () &#123;'设置方法'&#125;; //返回这个instance，覆盖this return instance;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[观察者模式实例详解]]></title>
      <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3.html</url>
      <content type="text"><![CDATA[观察者模式又名发布-订阅者模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，自动刷新状态。观察者模式提供给关联对象一种同步通信的手段，使某个对象与依赖它的其他对象之间保持状态同步。 角色： 观察者（订阅者） 接口或抽象类。当被观察者状态发生变化时，会得到通知 被观察者（发布者 或者 主题） 当需要被观察的状态发生改变时，需要通知队列中的所有观察者对象。 需要维持（添加，删除，通知）一个观察者对象列表 观察者模式案例步骤： 1. 提供一个发布者（负责信息发布） 2. 提供观察者（信息发布后需要采取行动的对象） 3. 注册观察者（将观察者注册到发布者的客户列表） 4. 发布者发布信息（事件触发） 场景：女神Rose（发布者）、追求者Jack（观察者）、追求者Tom（观察者）结构：多个发布者，多个观察者，发布者同时是观察者，观察者同时是发布者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//提供发布者var publisher = &#123; //把观察者注册到客户列表，fn代表看到信息时的反应，type为信息的类型 addClient : function (fn, type) &#123; //容错性处理 var type = type || ''; //判断this.client[type]是否存在（是否已经注册） if (typeof this.client[type] !== 'object') &#123; this.client[type] = []; //不存在的话创建数组存储客户 &#125; //观察者反应（函数）容错性处理 if (typeof fn !== 'function') &#123; throw '不是对信息的反应' &#125; //注册观察者 this.client[type].push(fn); &#125;, //移除观察者 removeClient : function (fn, type) &#123; this.publish(fn, type); &#125;, //信息发布,这里参数type需要在fn之前，因为输入参数时无论删除发布type是必输 publish : function (type, fn) &#123; //如果fn在之前，会把实参eat赋值给形参fn var type = type || ''; for (var i = 0; i &lt; this.client[type].length; i++) &#123; //判断是发布信息还是移出观察 if (typeof fn === 'function') &#123; //匹配删除对象 if (this.client[type][i] === fn) &#123; this.client[type].splice(i, 1); &#125; &#125; else &#123; //发布信息时，不要提供函数 this.client[type][i](); &#125; &#125; &#125;&#125;;//封装一个函数快速创建发布者function quickPub (obj) &#123; for (var k in publisher) &#123; //只拷贝实例方法 if (publisher.hasOwnProperty(k) &amp;&amp; (typeof publisher[k] === 'function')) &#123; obj[k] = publisher[k]; &#125; &#125; //先提前把客户列表设置为对象 obj.client = &#123;&#125;&#125;var rose = &#123; //作为发布者 hungry : function () &#123; this.publish('eat'); &#125;, //作为观察者 playRose : function () &#123; console.log('和jack一起玩') &#125;&#125;;var jack = &#123; hungryEventJack : function () &#123; console.log('亲自下厨'); &#125;, play : function ()&#123; this.publish('play') &#125;&#125;;var tom = &#123; hungryEventTom : function () &#123; console.log('下馆子'); &#125;&#125;;//让rose与jack成为发布者，拥有发布者的方法quickPub(rose);quickPub(jack);//注册观察者rose.addClient(jack.hungryEventJack, 'eat');rose.addClient(tom.hungryEventTom, 'eat');jack.addClient(rose.playRose, 'play');//发布信息rose.hungry(); //rose的观察者会反馈jack.play(); //jack的观察者会反馈]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP状态码]]></title>
      <url>%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81.html</url>
      <content type="text"><![CDATA[HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。 状态码如 200 OK，以3位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。 2XX 成功2XX 的响应结果表明请求被正常处理了。 200 OK表示从客户端发来的请求在服务器端被正常处理了。 204 No Content表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。一般在只需要从客户端往服务器发送消息，而对客户端不需要发送新消息内容的情况下使用。 206 Partial Content表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。 3XX 重定向3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 301 Moved Permanently永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。 302 Found临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。 303 See Other该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。303 与 302 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源。 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。 304 Not Modified该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但为满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。 附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match, If-Modified-Since, If-None-Macth, If-Range, If-Unmodified-Since 中任一首部。 307 Temporary Redirect临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。 4XX 客户端错误4XX 的响应结果表明客户端是发生错误的原因所在。 400 Bad Request该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。 401 Unauthorized该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。 403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了。未获得文件系统的访问授权，访问权限出现某些问题等情况都可能是发生 403 的原因。 404 Not Found该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 5XX 服务器错误5XX 的响应结果表明服务器本身发生错误。 500 Internet Server Error该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。 503 Service Unavailable该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。 状态码与状况的不一致不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js 常用接口]]></title>
      <url>%2FNode.js%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3.html</url>
      <content type="text"><![CDATA[Node.js 就是运行在服务端的 JavaScript 。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、异步（非阻塞式）I/O、单线程模型。轻量又高效。 http创建服务器123456789101112131415161718192021//导入http模块中的功能const http = require('http');//2. 创建http服务const server = http.craeteServer(function(request, response)) &#123; //request -&gt; 请求，客服端发送给服务器的 //response -&gt; 响应，服务器对客户端的响应 //告诉客户端响应完成 response.end(); //必须，有且只有一个&#125;）；//3. 启动服务/**参数1. 端口*参数2. 监听的ip地址*参数3. 回调 -&gt;当服务器成功启动执行回调*/server.listen(80, '127.0.0.1', function()&#123; console.log('服务器成功创建并启动监听');&#125;) 发送数据12345678910111213141516171819202122//1. 导入模块const http = require('http');//2. 创建http服务const server = http.craeteServer(function(request, response)) &#123; //给客户端指定编码格式和网页状态码 //参数1：网页状态码 //参数2：设置网页的编码格式 response.writeHead(200, &#123;'Content-Type' : 'text/html;charset=utf-8;'&#125;); //write可以使用多次，向客户端发送数据 response.write('发送的数据1'); response.write('发送的数据1'); //告诉客户端响应完成 response.end(); //必须，有且只有一个&#125;）；//3. 启动服务// 参数2 默认就是本机地址// 参数3 默认也可以不要server.listen(80) 请求url过滤12345678910111213141516171819202122232425const http = require('http');let a = 0;// 回调方法是每一次请求都会进来const server = http.createServer(function(req, res)&#123;// req.url 能获取到客户端发送的请求地址 //过滤请求url if (req.url == '/favicon.ico')&#123; return; &#125; //请求url默认跳转 else if (req.url == '/') &#123; req.url = '/index.html'; &#125; //404未找到 else &#123; res.writeHead(404, &#123;'Content-type': 'text/html'&#125;); res.end('404'); &#125; res.end();&#125;);server.listen(80); fs（File System文件系统）const fs = require(‘fs’); 读取文件12345678910111213141516/** 参数1： 要读取文件的路径* 参数2： 回调函数* 注意：* 读文件是耗时操作，所以要用回调* err永远是回调函数第一个参数* Buffer是二进制数据的暂缓去* 可以用toString()将二进制转换成可阅读的字符串fs.readFile('note.txt', function(err, data) &#123; if (!err)&#123; console.log(data.toString()); &#125; &#125;)console.log(1);//由于异步，先打印1再打印文件内容 文件操作文件操作 覆盖文件内容fs.writeFile(文件的路径， 写入的内容， 回调函数); 123fs.writeFile('note.txt', '写入的内容', function(err)&#123; if (!err)&#123;console.log('写入成功')&#125;&#125;) 往最后追加内容fs.appendFile(文件的路径， 写入的内容， 回调函数)； 删除文件fs.unlink(文件的路径， 回调函数)； 文件夹操作 创建文件夹fs.mkdir(文件夹名， 回调函数)；如果已经存在，则为err 删除文件夹fs.rmdir(文件夹名，回调函数)；如果不存在，则为err 查询文件状态判断为文件或者是文件夹fs.stat(文件/文件夹名路径， 回调函数)；回调的第二个参数为文件的状态。12345678910111213const fs = require('fs');fs.stat('note.txt', function(err, status)) &#123; if (!err) &#123; //判断文件 if(status.isFile())&#123; console.log('文件'); &#125; //判断文件夹 else if(status.isDirectory())&#123; consoloe.log('文件夹'); &#125; &#125;&#125;) 读取文件夹里的内容读取到所有文件包括文件夹12345fs.readdir(文件的路径， function(err, files))&#123; if(!err)&#123; console.log(files); &#125;&#125; Path12345//导入模块const path = require('path');//举例const myPath = 'C:/abc/123.txt'; 连接路径 path.join(路径1，路径2…); 路径1/路径2/… 获取文件名 path.basename(myPath); 123.txt 获取当前文件所在路径(__dirname也可实现) path.dirname(myPath); C:/abc 获取扩展名 path.extname(myPath); .txt path.parsepath.parse(&apos;C:\\path\\dir\\file.txt&apos;) // 返回: { root : &quot;C:\\&quot;, dir : &quot;C:\\path\\dir&quot;, base : &quot;file.txt&quot;, ext : &quot;.txt&quot;, name : &quot;file&quot; } url.parseurl.parse() 方法会解析一个 URL 字符串并返回一个 URL 对象(需要添加参数 true )。12345678910111213141516171819202122const url = require('url');let myurl = 'http://127.0.0.1:80/a/b/c?name=shine&amp;age=20';//使用parse对url进行格式化//第二个参数为true则将字符串转换成对象，可以用点语法获取对象的值let query = url.parse(myurl, true).query;console.log(query.name); //shine//格式化字符串const querystring = require('querystring');let queryStr = url.parse(myurl).query; //name=shine&amp;age=20let obj = querystring.parse(queryStr);console.log(obj); //&#123;name : 'shine', age : '20'&#125;//获取访问路径let pathname = url.parse(myurl).pathname;console.log(pathname); // /a/b/c//获取端口let port = url.parse(myurl).port;console.log(port); // 80]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[作用域]]></title>
      <url>%2F%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
      <content type="text"><![CDATA[作用域直白的意思的作用范围。 块级作用域：{ 与}之间的称为块级作用域。在Java与C语言中有块级作用域，而JavaScript中没有块级作用域。 词法作用域JavaScript中采用的是词法作用域。在代码编写过程中，不需要运行，变量的作用域就已经确定。 动态作用域：变量的作用域取决于当时的执行环境。 词法作用域的规则 词法作用域中的访问原则——就近原则 首先在当前作用域中查找，如果没有就去上一级的作用域中查找，直到全局作用域，如果都没有返回undefined或者报错(函数)。 注意：外层作用域不能访问内层作用域。 只有函数才能限定作用域范围，函数内允许访问函数外的数据。 123456var a = 10;function fun() &#123; console.log(a); //10 var b = 1;&#125;console.log(b); //undefined 变量提升 变量提升变量提升时只会提升到当前作用域的顶端。 JavaScript的解析过程第一阶段：预处理（预解析）现将代码读取到内存中检查，会将所有的声明在此时进行标记。所谓的标记就是让JS解释器知道有这个名字，后面在使用名字的时候，不会出现未定义的错误。这个标记的过程就是提升。 用var定义的变量 用声明方式创建的函数 在函数表达式中，只会提升var声明的变量，并不会把整个函数表达式提升 第二阶段：执行阶段 覆盖问题 函数名和函数名一样时，后面的会覆盖前面的 变量名和变量名一样时，后面的会覆盖前面的 函数名和变量名一样时，优先读取函数。即可看成只提升函数的声明，不提升同名的变量声明。 作用域链 函数可以创建限定的作用域 函数内可以声明一个函数 函数中的函数也可以创建函数 所以，形成一条向上的作用域链 最里层的函数可以逐级向上读取作用域 外层的作用域读取不到里层的作用域 综合笔试题123456789101112131415161718192021222324252627function Foo() &#123; getName = function()&#123; console.log("1"); &#125;; return this;&#125;Foo.getName = function() &#123; console.log("2");&#125;;Foo.prototype.getName = function()&#123; console.log("3");&#125;;var getName = function() &#123; console.log("4");&#125;;function getName()&#123; console.log("5");&#125;//求出以下输出的结果Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); 思考过程：1234567891011121314151617181920//预解析function Foo() &#123; getName = function()&#123; console.log("1"); &#125;; return this;&#125;var getName; //变量声明提升function getName()&#123; //函数声明提升 console.log("5");&#125;Foo.getName = function() &#123; console.log("2");&#125;;Foo.prototype.getName = function()&#123; console.log("3");&#125;;getName = function() &#123; console.log("4");&#125;; Foo.getName(); 首先先声明了一个构造函数，其中有getName这个属性，但是随后对该属性进行了重新赋值，覆盖了原来的属性。所以，此时执行覆盖后的函数，输出2。 getName(); getName()只需要看最后两个函数。首先函数表达式进行变量提升，将var getName提升到顶端，但是函数主体依然不动。最后一个函数声明直接提升到var getName的后面，但是还是在第四个函数的前面。所以最后输出最后面的函数，就是4。 Foo().getName(); 先执行Foo()，得到Foo返回值对象的getName()。在执行Foo()时，返回值的this指向window。getName = function(){console.log(&quot;1&quot;);};是一个函数赋值语句，是全局变量，先向当前Foo函数作用域内寻找getName变量，没有找到，在全局作用域中查找，找到了全局中getName的console.log(4)语句，将此变量的值赋值为function(){console.log(&quot;1&quot;);};完成覆盖。 getName(); 因为上一步Foo().getName();执行完成后，变成window.getName()输出1。 new Foo.getName(); 由于优先级的关系，.语法优先级高于new，相当于new (Foo.getName) ()，实际上将getName函数作为了构造函数来执行，执行new 2输出2。 new Foo().getName(); 先执行创建构造函数new Foo(),再用实例里的getName方法，实例不能调用构造函数中方法，去原型对象中找到这个方法输出3。 new new Foo().getName(); 相当于new ((new Foo()).getName)在6的基础上，new 3输出结果3。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP 协议与报文]]></title>
      <url>%2FHTTP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%8A%A5%E6%96%87.html</url>
      <content type="text"><![CDATA[HTTP协议HTTP 协议与 TCP/IP 协议一样，用于客户端和服务端之间的通信。 HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。 请求报文 请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。 如果不是访问特点资源而是对服务器本身发起请求，可以用一个 * 来代替请求URI。 响应报文 响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的相应首部字段以及实体主体构成。 HTTP协议是一种不保存状态，即无状态协议。HTTP自身不对请求和响应之间的通信状态进行保存。是为了更快地处理大量事务，确保协议的可伸缩性。但是为了实现保持状态的功能，于是引进了 Cookie 技术。 告知服务器意图的HTTP方法GET：获取资源GET方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像 CGI （通用网关接口）那样的程序，则返回经过执行后的输出结果。 POST：传输实体主体虽然用 GET 方法也能传输实体主体，但一般不这样用。虽说 POST 的功能与 GET很相似，但 POST 的主要目的并不是获取响应的主体内容。 HEAD：获得报文首部HEAD 方法与 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。 OPTIONS：询问支持的方法用来查询针对请求 URI 指定的资源支持的方法。 CONNECT：要求用隧道协议连接代理CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL （Secure Sockets Layer，安全套接层）和 TLS （Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 格式： CONNECT 代理服务器名：端口号 HTTP版本 持久连接节省通信量HTTP协议初始版本中，每进行一次通信就要断开一次 TCP 连接。因此，每次请求就会造成无谓的 TCP 连接建立和断开，增加通信量的开销。为了解决上述 TPC 连接问题，HTTP/1.1想出了持久连接的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 管线化持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需要等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。 使用 Cookie 的状态管理HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。无法根据之前的状态进行本次的请求处理。于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。 HTTP 报文内的 HTTP 信息用于 HTTP 协议交互的信息被称为 HTTP报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。 请求报文与响应报文的结构 请求行 包含用于请求的方法，请求URI和HTTP版本。 响应行 包含表明响应结果的状态码，原因短语和HTTP版本。 首部字段 包含表示请求和响应的各种条件和属性的各类首部。 一般有4种首部，分别是： 通用首部 请求首部 响应首部 实体首部 其他 可能包含HTTP的RFC里未定义的首部（Cookie等）。 编码提升速率HTTP 在传输数据时可以按照数据原貌直接传输，也可以进行编码提高效率。但是也同时会消耗更多的 CPU 资源。 报文（message） 是 HTTP 通信中的基本单位，由 8 位组字节流组成，通过 HTTP 通信传输。 实体（entity） 作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。 HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。 内容编码可以将实体信息原样压缩，内容编码后的实体由客户端接收并负责解码。常见的有 gzip（GNU zip）。 分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用 “0（CR+LF）” 来标记。使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。 多部分对象集合在 MIME （多用途因特网邮件扩展）机制中，会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。HTTP 协议中也采纳了多部分对象集合，发送一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。多部分对象集合包含的对象如下： multipart/form-data 在 Web 表单文件上传时使用。 multipart/byteranges 状态码206（Partial Content ，部分内容）响应报文包含了多个范围的内容时使用。 在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 Content-type 。使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行之前插入 “–” 标记，而在多部分对象集合对应的字符串的最后插入 “–” 作为结束。 获取部分内容的范围请求如果传输数据时中断，为了避免重新加载所有数据，需要能从中断处恢复下载。要实现该功能需要指定下载的实体范围。这种指定范围发送的请求叫做范围请求（Range Request）。 执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。例如： 5001 ~ 10000 字节 Range: bytes=5001-10000 从 5001 字节之后全部的 Range: bytes=5001- 从开始到 3000 字节和 5000~7000 字节的多重范围 Range: bytes=-3000, 5000-7000 针对范围请求，响应会返回状态码为 206 Pratial Content 的响应报文。如果服务器端无法响应范围请求，则回返回状态码 200 OK 和完整的实体内容。 内容协商返回最合适的内容当浏览器的默认语言为中文或英语时，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）。 内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。包含在请求报文中的某些首部字段就是判断的基准。例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language。 内容协商技术有以下3种类型。 服务器驱动协商（Server-driven Negotaition） 由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优的内容。 客户端驱动协商（Agent-driven Negotiation） 由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自动切换成 PC 或移动端页面。 透明协商（Transparent Negotiation） 是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象继承方法]]></title>
      <url>%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95.html</url>
      <content type="text"><![CDATA[继承的概念：通过一定的方式实现让某个类型A获取另外一个类型B的属性和方法。其中类型A称为子类型，类型B称为父类型或超类型。 JavaScript中的继承：Object是所有对象的父类型，所有Javascript中的对象都是直接或间接继承自Object。 继承有两种方式：接口继承和实现继承，在JS中只支持实现继承，实现继承主要依赖原型链来完成。 说明：其他语言中继承通常通过类来实现，JS中没有类的概念（ES6新增了class）。JS中的继承是某个对象继承继承另外一个对象，是基于对象的。 1. 属性拷贝（混入式继承）属性拷贝是浅拷贝，复制引用类型时，只会复制地址，两者会共享同一数据，修改一个会影响另外一个。123456789101112var obj1 = &#123; name : '小明', age : 20, friends : ['小红', '小智']&#125;;var obj2 = &#123;&#125;;//obj2继承obj1的属性for (var k in obj1) &#123; obj2[k] = obj1[k]; //遍历复制属性&#125;obj2.friends.push('小王'); //为子对象添加一个属性//obj1的friends里也会被增加一个小王 在ES6中添加了一个Object.assign()属性 123456789var copy = &#123;&#125;;var obj1 = &#123;name : '小明'&#125;;var obj2 = &#123;age : 20&#125;;var obj3 = &#123;friends : ['小红']&#125;;//第一个参数：目标对象，后面的参数：需要拷贝的对象Object.assign(copy, obj1, obj2, obj3);console.log(copy); //输出&#123;name : '小明',age : 20,friends : ['小红']&#125;copy.friends.push('小王');console.log(obj3); //输出&#123;friends : ['小红', '小王']&#125; 同样会影响父对象中的引用类型属性。 2. 原型式继承利用构造函数创建出来的对象可以使用原型对象中的属性和方法 简单的原型式继承：12345function Fun() &#123;&#125;Fun.prototype.des = 'des';var obj = new Fun();console.log(obj.des); //des//构造函数创建的对象可以使用原型的属性方法 复杂一点的原型式继承：12345678910function Fun1() &#123; this.name = '名字';&#125;Fun1.prototype.des = 'des';function Fun2() &#123;&#125;Fun2.prototype = Fun1.prototype;var obj = new Fun2(); //无法获取到name属性//应该修正构造器的指向//Fun2.prototype.constructor = Fun2;console.log(obj.constructor); //默认指向Fun1 问题： 1.原型式继承创建出来的子对象的构造器属性默认指向父构造函数，需要修正consturctor的指向。2.无法获取到父对象构造函数中的属性。 扩展内置对象系统内置的对象(Array、Object等)都可以通过在原型对象上添加属性的方式来让所有子对象拥有这一属性。123456Array.prototype.add = '添加的属性';Array.prototype.addFun = function () &#123; console.log(this.add);&#125;;var arr = [1, 2, 3];arr.addFun(); //添加的属性 不建议使用这种方式，在实际开发中通常是多人合作。如果都扩展内置对象，后期将难以维护，同时也会引发覆盖等安全问题。 安全的扩展内置对象 提供一个自定义构造函数 设置构造函数的原型对象是内置对象的实例 123456789101112//提供一个构造函数function MyArray() &#123;&#125;;//设置构造函数的原型对象为内置对象的实例MyArray.prototype = new Array();MyArray.prototype.des = 'des';MyArray.prototype.logDes = function () &#123; console.log(this.des);&#125;var arr = new MyArray();arr.push('123');arr.logDes(); //desconsole.log(arr); // [123]; 继承来自Array的属性方法 3. 原型链继承实现原型链继承的过程：先提供一个子构造函数和父构造函数，设置子构造函数的原型对象是父构造函数的实例。12345678910111213//设置父构造函数function Person() &#123; this.name = '名字';&#125;//设置父构造函数的原型对象Person.prototype.des = 'des';//设置子构造函数function Student() &#123;&#125;//设置原型链继承Student.prototype = new Person();var stu = new Student();console.log(stu.des); //desconsole.log(stu.name); //名字 原型链继承的注意点在完成原型链继承之后，再进行： 修正构造器属性的指向 设置子构造函数的原型对象的属性和方法，并且不要使用字面量的方式修改子构造函数属性，会产生替换，应使用对象的动态特性设置 原型链继承的问题 无法传递参数给父构造函数 用子构造函数创建多个实例对象时，只会复制引用类型数据地址，会产生共享问题。123456789101112131415161718192021//设置父构造函数function Person(name) &#123; this.name = name; this.friends = ['小明'];&#125;//创建子构造函数function Student(num) &#123; this.num = num;&#125;//设置原型链继承Student.prototype = new Person();//修正构造器指向Student.prototype.constructor = Student;//创建实例对象，无法传递参数到父构造函数var stu1 = new Student('2017');var stu2 = new Student('2018');//设置stu1，也会影响stu2stu1.friends.push = '小红';console.log(stu1); //2017 [小明, 小红]console.log(stu2); //2018 [小明, 小红] Object.creat()方法实现继承作用：创建一个对象，并设置该对象的原型对象为指定对象兼容性：ES51234567891011121314var obj = &#123; name : '名字'&#125;;//o为创建的对象，设置它的原型对象为objvar o = Object.creat(obj);console.log(o.name); //名字//相当于var newObj = &#123; name : '名字'&#125;;//非标写法 var newO=&#123;&#125;; newO.__proto__ = newObj;function Fun()&#123;&#125;;Fun.prototype = newObj;var newO = new Fun(); 4. 借用构造函数（经典继承 | 伪对象继承）call和apply的用法用法：Function.prototype.call/apply()作用：借用其他对象的方法参数输入:第一个参数为需要借参数的对象，之后的为输入的参数不同点：call(对象， 参数1， 参数2…) 参数列表apply(对象， [参数1， 参数2…]) 参数数组 关于this的指向：使用了call或apply方法后，调用的this指向被绑定的对象（第一个参数）。 借用构造函数的用法借用构造函数实现继承解决了无法传递参数给父构造函数的问题12345678910111213function Person(name) &#123; this.name = name;&#125;function Student(num, name) &#123; this.num = num; //通过借用构造函数调用父构造函数的方法实现继承 Person.call(this, name);&#125;//创建不同的实例对象var stu1 = new Student('2017', '小明');var stu2 = new Student('2018', '小红');console.log(stu1); // 2017 小明console.log(stu2); // 2018 小红 5. 组合继承 借用构造函数继承获取实例属性和方法 原型式继承获取原型属性和方法 组合继承 = 借用构造函数继承 + 原型式继承问题：子构造函数原型对象与父构造函数原型对象共享同一数据。 123456789101112131415161718192021222324252627//设置构造函数属性function Person(name) &#123; this.name = name;&#125;//设置原型对象属性方法Person.prototype.des = 'des';Person.prototype.logDes = function () &#123; console.log(this.des);&#125;//创建子构造函数function Student(num, name) &#123; this.num = num; //通过借用构造函数调用父构造函数的方法实现继承 Person.call(this, name);&#125;//利用原型式继承实现继承父构造函数原型对象Student.prototype = Person.prototype;//创建不同的实例对象var stu1 = new Student('2017', '小明');var stu2 = new Student('2018', '小红');console.log(stu1); // 2017 小明console.log(stu2); // 2018 小红//子构造函数与父构造函数共享同一个原型对象Student.prototype.des = 'desStu';//子构造函数原型对象设置了属性，父构造函数原型对象也受到影响var obj = new Person('小王');obj.logDes(); //desStu 6. 深拷贝继承浅拷贝（地址拷贝）1234var copy = &#123;&#125;;for (var k in obj) &#123; copy[k] = obj[k];&#125; 浅拷贝是对值类型属性的复制，遇到引用类型数据时，只能复制其地址 深拷贝（完全拷贝） 创建一个深拷贝的函数，提供2个参数，一个是目标对象，一个是需要拷贝的对象 for in遍历目标对象获取属性，进行判断属性的类型 如果是值类型，直接赋值 如果是引用类型，再调用这个函数，拷贝引用类型里的数据 函数一般是直接调用，不需要修改数据。所以可以当作值类型直接复制地址123456789101112131415161718192021function deepClone(obj, copy) &#123; //被拷贝的对象必须是一个对象 copy = copy || &#123;&#125;; //遍历在目标对象中的所有属性 for (var k in obj) &#123; //判断是否是自身的属性，防止遍历到原型属性 if (obj.hasOwnProperty(k)) &#123; //如果是引用类型的属性（function除外）就要进行深拷贝 if (typeof obj[k] === 'object') &#123; //判断属性是数组还是对象 copy[k] = obj[k].constructor === Array ? [] : &#123;&#125;; //递归进更深一层 deepClone(obj[k], copy[k]); &#125; else &#123; //值类型或者是函数直接复制 copy[k] = obj[k]; &#125; &#125; &#125; return copy;&#125; 在判断对象是否是数组时，我们也可以用到一个方法Array.isArray()括号内输入需要判断的对象，返回值是Boolean类型。但是这个方法是ES5才出来，所以具有兼容问题。 利用深拷贝实现继承 借用构造函数获取实例属性，call和apply 深拷贝获取原型属性 完美的拷贝，独立并且互不影响。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原型链图解]]></title>
      <url>%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%9B%BE%E8%A7%A3.html</url>
      <content type="text"><![CDATA[原型链的结构 每一个对象都是由构造函数创建出来的。 每一个构造函数都有对应的原型对象。 原型对象也是一个对象，所以原型对象也是由构造函数创建出来的。 以上，形成原型链。 原型链的顶端是Object.prototype，Object.prototype构造出空函数function () {}，空函数构造出Object与Function Object.prototype的构造函数是Object Object.prototype.__proto__ == null 构造函数的也是一个对象，它的构造函数是Function Function也是一个对象，它的构造函数是它自己Function Function的原型对象是空函数function () {} 空函数function () {}的原型对象是Object.prototype Objcet的构造函数是Function Object.__proto__是空函数function () {} Object与Function的关系JavaScript中所有对象(除了Object.prototype)都是Object的实例Function和Object互为对方的实例12345console.log(Function instanceof Function); //trueconsole.log(Function instanceof Object); //trueconsole.log(Object instanceof Function); //trueconsole.log(Object instanceof Object); //trueconsole.log(Object.prototype instanceof Object); //false 原型链属性搜索规则就近原则（屏蔽原则）：通过对象.属性访问属性时，首先会查找自身是否含有该属性，如果没有，会查找其原型对象是否含有该属性，如果有直接返回该属性的值，如果没有就会沿着原型链继续向上查找，直到找到该属性。如果都没有，返回undefined或报错(函数)。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Object 的静态成员]]></title>
      <url>%2FObject%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%BB%8B%E7%BB%8D.html</url>
      <content type="text"><![CDATA[静态成员：构造函数对象自己的属性和方法实例成员：直接定义在实例上的属性和方法原型成员：直接定义在原型对象上的属性和方法 所有对象都是Object的实例，所以可以访问Object的静态成员 Object.toString：返回对象的字符串描述信息 object类型返回[object Object] 函数、数组类型返回字符串形式 Number类型可调用该方法，传递参数，表示转换进制 Object.apply/call：调用其他对象的方法 Object.arguments：接收存储函数的实参 Object.assign：属性拷贝 Object.caller：返回一个函数的引用，这个函数调用了当前的函数；另外callee放回正在执行的函数本身的引用，它是arguments的一个属性，常用于递归函数。 Object.constructor：构造器属性，指向构造函数 Object.getPropertyOf：获取原型对象，相当于(.__proto__) Object.create：创建对象并设置原型对象 Object.getOwnPropertyDescriptor：获取实例属性的描述信息 configurable：是否可配置（是否可删除，是否可修改该属性） enumerable：是否可枚举（可用for..in遍历） value：值 writable：是否可重写（修改） Object.defineProperty：设置属性的描述信息 修改已经存在的属性，默认为true 添加新的属性，默认是false 参数：第一个参数为需要配置的对象，第二个参数为该对象需要配置的属性，第三个对象为该属性的描述对象 Object.getOwnPropertyName：获取对象所有实例属性的名字，不包括原型属性。返回一个数组 Object.keys：获取所有对象属性名，不包括原型属性和不可枚举属性 关于Object.getOwnPropertyName与Object.keys的差别 12345678&gt; var obj = &#123;name : '名字', age : 20&#125;;&gt; Object.prototype.des = 'des';&gt; //设置name属性不可枚举&gt; Object.defineProperty(obj, 'name', &#123;enumerable : false&#125;);&gt; //结果都不包含原型属性&gt; console.log(Object.getOwnPropertyName(obj)); //[name, age]&gt; console.log(Object.keys(obj)); //[age]&gt; Object.prevenExtensions：禁止扩展属性（不可以添加属性，可删可改）。可通过Object.isExtensible查询。 Object.seal：密封属性（禁止扩展和删除，禁止修改configurable和enumerable。可以修改属性的值）。可通过Object.isSealed查询。 Object.freeze：冻结属性（不可增删改）。可通过Object.isFrozen查询。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web与网络基础]]></title>
      <url>%2FWeb%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80.html</url>
      <content type="text"><![CDATA[Web使用一种名为HTTP(HyperText Transfer Protocol，超文本传输协议)的协议作为规范，完成从客户端到服务器端等一系列运作流程。可以说，Web是建立在HTTP协议上通信的。 3项WWW构建技术，分别是：作为页面的文本标记语言的HTML；作为文档传递协议的HTTP；指定文档所在地址的URL。 通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。 TCP/IP 分层管理TCP/IP协议族里最重要的一点就是分层。TCP/IP协议族按层次分别分为一下4层：应用层、传输层、网络层和数据链路层。把TCP/IP层次化是有好处的。比如某个地方需要改变设计时，只要把需要变动的层替换掉就好了。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由行动了。 TCP/IP协议族各层的作用如下。 应用层 应用层决定了向用户提供应用服务时通信的活动。 TCP/IP协议族内预存了各类通用的应用服务。比如，FTP（文件传输协议）和DNS（域名系统）服务就是其中两类。 HTTP协议也处于该层 传输层 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。 在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。 网络层（又名网络互连层） 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输线路。 链路层（又名数据链路曾，网络接口层） 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（网络适配器，即网卡），及光线等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围内。 TCP/IP 通信传输流 以HTTP为例，首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求。 接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据(HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号转发到网络层。 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样以来，发往网络的通信请求就准备齐全了。 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正的接收到由客户端发送过来的HTTP请求。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应首部消去。这种把数据信息把封装起来的做法称为封装（encapsulate）。 IP、TCP 和 DNS负责传输的IP协议按层次分，IP（Internet Protocol）网络协议位于网络层。IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址。IP地址致命了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。 在网络上，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。 无论哪台计算机、哪台网络设备，它们都无法全面掌握互联网中的细节。 确保可靠性的TCP协议按层次分，TCP位于传输层，提供可靠的字节流服务。所谓的字节流服务是指：为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把大数据准确可靠地传给对方。 TCP传输中的三次握手为了准确无误地将数据送达目标出，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN（synchronize）和ACK（acknowledgement）。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表握手结束。 负责域名解析的DNS服务DNS服务是和HTTP协议一样一样位于应用层的协议。它提供域名到IP地址之间的解析服务。用户通常使用主机名或域名来访问对方的计算机，计算机擅长处理数字而不是名称，因此，DNS服务应运而生。 DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。 URI 和 URLURI：统一资源标识符URL：统一资源定位符 URI就是某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。采用HTTP协议时，协议方案就是http。除此之外ftp、file等。 URI 用字符串标识某一互联网资源。而 URL 表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。 绝对URI格式 协议方案名 使用http:或者https:等协议方案名获取访问资源时要指定协议类型。 登录信息（认证） 指定用户名和密码作为从服务器端获取资源时必要的登录信息。可选项。 服务器地址 使用绝对URI必须指定待访问的服务器地址。地址可以是hwong.cn这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名。 服务器端口号 指定服务器连接的网络端口号。可选项，省略则自动使用默认端口号。 带层次的文件路径 指定服务器上的文件路径来定位特指的资源。 查询字符串 针对已指定的的文件路径内的资源，可以使用查询字符串传入任意参数。可选项。 片段标识符 通常可标记出已获取资源中的子资源（文档内的某个位置）。可选项。 参考资料：《图解HTTP》第一章]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构造函数与原型对象]]></title>
      <url>%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.html</url>
      <content type="text"><![CDATA[构造函数 函数也可以作为构造函数的参数 构造函数和工厂函数的区别： 构造函数首字母大写 构造函数内部会默认创建新的对象，并且默认返回这个对象 在创建对象的时候，通过new调用构造函数 返回值 构造函数内部没有return，返回默认新创建的对象 如果构造函数内部有return，分两种情况： 返回值类型，忽略该return，返回新创建的对象 返回值是引用类型的数据，会覆盖之前创建的对象，返回该引用类型数据的值1234567function Person(name, age) &#123; this.name = name; this.age = age; //return 'test'; 会忽略该return //return &#123;&#125;; 返回该对象&#125;var p1 = new Person('张三', 20); 实例和实例化使用构造函数创建对象的过程称为实例化，创建出来的这个对象叫做该构造函数的实例。 基本包装类型String、Number、Boolean 可以使用var str = new String(&#39;字符串&#39;)来创建字符串对象，这里typeof str //object var str1 = &#39;字符串&#39;或者var str2 = String(&#39;字符串&#39;)的类型都是string 我们还可以通过 var str = new Object(&#39;字符串&#39;)来创建字符串对象，也可以输入数字或true/false，Object会自动判断是哪种类型。这里typeof str //object 基本数据类型也能有属性或者方法，在内部会进行 创建一个与之对应的对象 利用这个对象访问属性和方法并返回结果 返回结构之后，立即销毁该对象var str = &#39;demo&#39;; console.log(str.length); //4 thisthis指向的是 函数的调用者 或者是 事件的调用者 this -&gt;指向具体的对象函数调用: 作为对象的方法调用 this-&gt;当前的对象 普通函数调用 this-&gt;window 通过new构造函数调用 this-&gt;构造函数内部创建的新对象 使用call / apply调用(函数上下文调用) this-&gt;第一参数 this在事件指令表示事件源this在定时器中表示windows new我们经常利用new运算符去声明新的对象 new运算符接受一个函数F及其参数： new F(arguments…)这一过程分为三步： 创建类的实例。这步是把一个空的对象的__proto__属性设置为F.prototype。 初始化实例。函数F被传入参数并调用，关键字this被设定为该实例。 返回实例，如果没有return，默认返回this引用。 new 运算符的作用是创建一个实例对象。这个对象可以是用户自定义的，也可以是带构造函数的一些系统自带的对象。 new 运算符可以让 this 指向新的对象 所谓“构造函数”，其实就是普通函数内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。为了和普通函数区分， 第一个字母大写 例如：123456789function fun() &#123; alert(this）; //this指向window&#125;fun();function fn() &#123; alert(this）; //this指向fn&#125;new fn(); //添加了new的函数，this指向的是新的对象 私有方法和特权方法私有变量/方法：定义在构造函数内部的变量和方法，私有方法本身是可以访问构造函数内部的所有属性的，即私有属性和共有属性。但是私有方法不可以在构造函数的外部被调用。123456function Fun() &#123; var private = '私有变量'; funciotn privateFun() &#123; console.log('这是一个私有方法'); &#125;&#125; 特权方法：可以当问私有变量和私有函数的实例方法，使用this.来转换。123456789function Fun() &#123; this.name = '名字'; this.showName = funciotn () &#123; //通过this定义一个特权方法 console.log(this.name); &#125;&#125;var obj = new Fun();obj.showName(); //名字 原型对象（prototype） 什么是原型对象？ 在构造函数创建出来的时候，系统会默认创建一个对象和这个构造函数关联，这个对象就称为这个构造函数的原型对象 原型对象的作用？ 使用构造函数创建的对象默认就可以使用原型对象中的属性和方法 怎么访问原型对象？ 构造函数.prototype 对象.__prototype__ 注意：`__prototype__`不是ECMA标准里的属性 怎么设置原型对象？ 原型对象本质也是对象，利用对象的动态特性也可以设置原型对象的属性和方法 使用字面量的方式创建（替换原型） 关于原型对象的替换 替换原型对象之前所创建的对象和替换之后创建的对象，它们的原型对象不是同一个原型对象。（切断） 替换原型对象之后，constructor指向Object，需要在替换时修正构造器的指向 12345678910111213function Person()&#123;&#125; //创建构造函数var p1 = new Person(); //创建对象var obj = &#123; /*修正时需要加一段代码， constructor : Person, 指向原来的原型对象，这样之前创建的对象才能正确使用新的属性方法*/ des : '一段描述'&#125;//替换原型对象Person.prototype = obj;var p2 = new Person();console.log(p1.des); //undefined 替换之前没有des属性console.log(p2.des); //一段描述 原型对象的属性 访问原型对象的属性 对象.属性 构造函数.prototype.属性 属性的访问原则 就近原则： 使用对象.属性访问属性的时候，首先会去找自己身上的属性（实例属性），如果找到就返回该值，如果没有，会去该对象构造函数原型对象上找是否有这个属性（原型属性）。如果都没有，返回undefined或报错(函数)。 设置原型对象的属性 通过构造函数.prototype.属性来设置换着替换原型对象属性 如果属性是引用类型的数据，可以通过实例对象.引用对象.属性的方式修改 关于实例对象中的属性与原型对象中的属性虽然能通过实例对象访问原型对象中的值，但不能通过实例对象重写原型中的值，当为实例对象添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，换句话说，添加的这个属性只会阻止我们访问原型中的那个属性，但不会对原型中属性产生任何影响。不过使用delete操作符可以完全删除实例属性，从而让我们可以重新访问原型中的属性。 属性存在的检测 for..in： 判断对象中是否存在指定的属性。既可以检测实例属性也可以检测原型属性。 hasOwnProperty()方法 ：判断对象中是否存在指定的实例对象中。 补充：对象(Object)数据类型 &gt; 对象就是带有**属性**和**方法**的*数据类型* 例如 `Array`、`Date`等，我们最常用的`Function`也是一个对象，虽然 1typeof function()&#123;&#125;; //"function" 但是Function实例和其他类型的实例没有什么区别，都是对象，只不过`typeof`操作符对其做了特殊处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象基本介绍与创建对象]]></title>
      <url>%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.html</url>
      <content type="text"><![CDATA[对象（Object）是什么？ 在软件系统中，对象具有唯一的标识符，对象包括属性（Properties）和方法（Methods），属性就是需要记忆的信息，方法就是对象能够提供的服务。在面向对象（Object Oriented）的软件中，对象（Object）是某一个类（Class）的实例（Instance）。 —— 维基百科 面向对象语言的特点：有类(class)的概念，如C++、Java。Javascript没有类的概念，基于原型，支持面向对象。 基本数据类型 string、 number、 boolean、 null、 undefined null、undefined分别表示没有声明和声明后没有初始化的变量、对象，是两个简单的值，其余三个有对应的包装对象Number、Boolean、String 面向对象三大特性 封装 封装就是把过程和数据封闭起来，对数据的访问只能通过开放的接口 作用：方便维护，提高代码的复用性，信息隐蔽 继承 子类对象继成使用父亲的属性和方法 多态 多态是指两个或多个属于不同类的对象，对于同一个消息（方法调用）做出不同响应的方式 Javascript天生就具备多态的特性（弱类型语言） 创建对象 字面量式声明对象 使用场景：只需要简单的创建几个对象 123var obj = &#123; name : 'object'&#125;; 问题：在创建同类型的代码时存在大量重复代码 使用内置的构造函数 系统内置的构造函数: Object、Array、Date、Function等 123var obj = new Object();obj.name = 'object';//等价于 var obj = &#123;&#125;; 问题：复用性不好，存在大量冗余重复代码，与字面量方式类似 简单的工厂的函数 封装：把固定部分写在函数体中，不同的作为函数的参数传递进去 1234567891011//// 01提供函数(工厂函数)封装对象的创建过程function creat(name) &#123; //创建一个空的对象 var obj = new Object(); //设置属性和方法 obj.name = name; //返回对象 return obj;&#125;//创建对象var newObj = creat('objName'); 问题：创建不同类型对象时，无法识别对象 自定义构造函数创建对象 提供一个构造函数 通过this设置属性和方法 使用new构造函数创建对象 12345678910111213function Person(name, age) &#123; /* 默认会创建一个新的对象 var obj = new Object(); 默认会把新创建的对象赋值给this this = obj; */ this.name = name; this.age = age; /*默认会返回新创建的对象 return this;*/&#125;var p1 = new Person('张三', 20); 问题：破坏封装性，结构性不好，全局变量污染。创建多个对象时，内部属性方法一样，每次都会开辟一块新的内存空间，造成浪费解决办法：通过原型属性和方法 判断对象的类型 instanceof ：判断某一变量是否为一个对象的实例 用法：判断a是否是A的一个实例，a instanceof A；返回boolean isPropertyOf：判断一个对象是否是指定对象的原型对象 用法：判断object是否是obj的原型对象，object.isPropertyOf(obj); 返回boolean constructor ：构造器属性，获取对象是由哪一个构造函数所创建的 用法：获得实例对象a的构造函数 a.constructor; 返回a的构造函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[值类型与引用类型及在内存中的存储]]></title>
      <url>%2F%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html</url>
      <content type="text"><![CDATA[Part1 值类型与引用类型值类型与引用类型的定义 值类型（基本类型） 定义：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。 5种基本数据类型：string、number 、boolean、null、undefined。 引用类型 定义：存放在堆内存中的对象，变量保存的实际是一个指针，当我们需要访问引用类型时，存放在栈内存中的指针会将我们指向堆内存的数据。每块空间大小不一样，根据情况进行特定的分配。 常见的引用类型有：Array、Object、Function 值类型与引用类型的存储（传值与传址） 值类型的赋值：把右边存储的信息（具体数据）复制一份给左边的变量。 特点：值类型赋值只是简单的数据复制，互相不影响，是独立的。 12345var a = 10;var b = a; //具体数据的复制，复制之后a,b相互独立互不影响b = 1;console.log(a); //10console.log(b); //1 引用类型的赋值：把右边存储的信息（指向具体数据的地址）复制一份给左边的变量。 特点：共享同一份数据，修改其中一个对象属性的值也会影响另一个。 1234567var obj1 = &#123; num : 10 &#125;;var obj2 = obj1; //数据地址的复制，两个对象指向同一份数据，共享同一份数据。obj2.num = 1;console.log(obj1.num); //1 修改obj2的属性也会影响obj1console.log(obj2.num); //1 值类型与引用类型在函数中的应用 在函数中的参数有两种，一种是实参，就是实际的参数。还有一种是形参，形式参数，占位用的，函数调用之前是没有值的。 函数的调用：默认会把实参赋值给形参。 值类型作为函数的参数(值传递) 形参与实参相互独立，没有影响 12345678var num = 10;function fn(n) &#123;//默认会执行一步 n = num； n = 10; console.log(n); //10&#125;fn(num); //函数的调用console.log(num); //20 值传递时，形参实参互不影响 引用类型做为函数的参数(指针传递) 实参形参共享同一份数据，修改一个对象的值也会对另外一个对象产生影响 123456789var obj = &#123;num : 10&#125;; //定义一个对象function fn(object) &#123;//默认进行 object = obj； 此时进行了地址的传递 object.num = 1； //修改了一个源数据，所有指向改数据的对象的属性都进行了更改 object = &#123;other : others&#125;; //object新建一块内存空间，指针指向新建的空间 console.log(object.num); //undefined 新建的空间内部已经没有num属性&#125;fn(obj); //调用函数console.log(obj.num); //1 被object更改了属性 Part2 堆栈的概念堆栈的定义 堆（heap） 动态分配内存，大小不定，不会自动释放存储空间，堆中存储复杂类型数据 栈（stack） 自动分配内存恐怖关键，系统自动释放，栈中存储简单类型数据 栈是一中特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。 后进先出（Last in First out）,简称LIFO线性表 数据在堆栈中的表示JavaScript在内存中是如何表示的呢？我们可以通过以下例子来了解值类型和引用类型在内存中是如何存储的。 123456789101112var zs = &#123; name : 'zs', age : 10, sex : '男', dog : dog, //指向dog对象 run : function () &#123;&#125; //指向run函数&#125;;var dog = &#123; name : '旺财', age : 10, run : function () &#123;&#125; //指向run函数&#125;; 以上代码可以描述为图示的关系： Part3 深拷贝与浅拷贝浅拷贝在定义一个对象或数组的时候，变量在栈中只是存储了一个地址（指针），当我们复制该对象或数组的时候，复制的值也是该地址。在访问属性的时候，还是会通过复制的地址回溯到原来对象或数组指向的内存中。即两者共享了同一内存空间。修改一个对象的属性，另一个对象也会受到影响。1234567function Copy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c; &#125; 深拷贝当我们不希望复制后的对象还与原对象共享同一数据，两者独立时，我们可以使用深拷贝来解决，通过递归的方法，把原对象中的属性方法都遍历给新的对象。这样，两个对象的属性会存储在堆中的不同内存空间。123456789101112131415161718192021function deepClone(obj, copy) &#123; //被拷贝的对象必须是一个对象 copy = copy || &#123;&#125;; //遍历在目标对象中的所有属性 for (var k in obj) &#123; //判断是否是自身的属性，防止遍历到原型属性 if (obj.hasOwnProperty(k)) &#123; //如果是引用类型的属性（function除外）就要进行深拷贝 if (typeof obj[k] === 'object') &#123; //判断属性是数组还是对象 copy[k] = obj[k].constructor === Array ? [] : &#123;&#125;; //递归进更深一层 deepClone(obj[k], copy[k]); &#125; else &#123; //值类型或者是函数直接复制 copy[k] = obj[k]; &#125; &#125; &#125; return copy;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取DOM元素事件位置信息的常用方法]]></title>
      <url>%2Fclient%E3%80%81offset%E3%80%81screen%E3%80%81page%E3%80%81scroll%E7%9A%84%E6%AF%94%E8%BE%83.html</url>
      <content type="text"><![CDATA[在JavaScript的DOM操作中，我们经常需要获取元素或事件的宽高及定位信息。因此我们就需要用到一些属性来得到我们想要的信息。 Part1 client、scroll、offset元素属性的定义在w3c的官方文档里，我们可以看到这几个属性都归类在HTML DOM元素对象的属性方法中，适用于所有HTML元素，都是只读属性。 12345678element.clientHeight //在页面上返回内容的可视高度（不包括边框，边距或滚动条）element.clientLeft //元素的左边框的宽度,若左边出现了垂直滚动条，也包含滚动条的宽度element.offsetHeight //返回元素的高度，包括边框和填充，但不是边距element.offsetLeft //获取边框相对于具有定位属性的父对象的左边距element.scrollHeight //返回元素的整体高度（包括带滚动条的隐蔽的地方）element.scrollLeft //滚动条卷去隐藏的距离 clientHeight、scrollHeight、offsetHeight的比较clientclientHeight：可见区域的宽度，不包括boder的宽度，如果区域内带有滚动条，还应该减去横向滚动条不可用的高度，正常的是17px，其实就是滚动条的可滚动的部分了，其实clientHeight与height的高度差不多，如果不带滚动条的话他们的值都是一样的，如果带有滚动条的话就会比height值少17px；火狐与IE下均为一致。注意，对于类型&lt;i&gt;,&lt;code&gt;和&lt;span&gt;这些内联元素,clientWidth和clientHeight总是返回0。 scrollscrollHeight：同样不包含border,由height与padding相加。若包含滚动条，scrollHeight就是滚动条可滚动的距离。（height与padding相加在减去滚动条的高度，默认为17px）。直观的说法就是元素的内容区域加上它的内边距再加上任何溢出内容的尺寸。当内容正好和内容区域匹配而没有溢出时，这些属性与clientWidth和clientHeight是相等的。但当溢出时，它们就包含溢出的内容，返回值比clientWidth和clientHeight要大。 offsetoffsetHeight：元素的offsetHeightw值包括该元素的边框,元素的垂直内边距,元素的水平滚动条(若出现水平滚动条),以及元素的样式高度。实际值为height + padding + border。 测试代码123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试代码&lt;/title&gt; &lt;style&gt; div&#123; overflow: scroll; /*设置滚动条*/ position: absolute; left: 1500px; width: 300px; height: 300px; border: 5px solid #000; padding: 10px; margin: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; console.log('clientWidth: '+ div.clientWidth); //320 padding+width 有滚动条时 303 padding+width-scroll(默认17px) console.log('clientLeft: '+ div.clientLeft); //5 边框的宽度，有滚动条就加滚动条宽度 console.log('offsetWidth: '+ div.offsetWidth); //330 boder + padding + width console.log('offsetLeft: '+ div.offsetLeft); //1520 获取边框相对于具有定位属性的父对象的左边距 console.log('scrollWidth: ' + div.scrollWidth); //320 padding + width 有滚动条时 303 padding+width-scrollWidth(默认17px) console.log('scrollLeft: ' + div.scrollLeft); //0 滚动条卷去的部分&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Part2 offset、client、screen、page在DOM事件中的定义在文档中，以上4个属性都归类在DOM Event中，属于事件状态，需要与函数结合起来使用，函数不会在事件发生前执行。常见的事件有鼠标点击、键盘按下等，事件发生后，我们就能检测相应的属性。 screenscreenX:鼠标位置相对于用户屏幕水平偏移量，此时的参照点也就是原点是屏幕的左上角。 clientclientX:跟screenX相比就是将参照点改成了浏览器内容区域的左上角，该参照点会随之滚动条的移动而移动，也就是说，他计算left或top时直接忽略了滚动条的高和宽，它的参考点是浏览器可见区域的左上角，而不是页面本身的body左上角原点，计算数值和滚动条是否滚动没有关系，只是绝对的计算鼠标点距离浏览器内容区域的左上角的距离，忽略了滚动条的存在。 pagepageX：参照点是页面本身的body原点，而不是浏览器内容区域左上角，它计算的值不会随着滚动条而变动，它在计算时其实是以body左上角原点（即页面本身的左上角，而不是浏览器可见区域的左上角）为参考点计算的，这个相当于已经把滚动条滚过的高或宽计算在内了，所以无论滚动条是否滚动，他都是一样的距离值。 pageX = clientX + ScrollLeft(滚动条滚过的水平距离)pageY = clientY + ScrollTop(滚动条滚过的垂直距离) offsetoffsetX：offsetX 表示鼠标指针位置相对于触发事件的对象的 x 坐标。不包含边框，所以可以为负值。 总结在实际开发中，我们经常要使用以上的方法来获得我们需要的值。首先，我们应该注意每一种属性的区别，了解他们是如何计算出来的，不至于在开发中张冠李戴，出现错误。其次，以上各种属性在不同浏览器中也有兼容问题，也是我们必须要要小心的地方，因为你可能写对了名字，但是在这个浏览器中无效，那也是白忙活一场。所以，在开发时，应尽量避免出现这些问题，多进行验证，这样才能保证代码的正确性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[offset类属性与style类属性的区别]]></title>
      <url>%2Foffset%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8Estyle%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="text"><![CDATA[offset类属性与style类属性的区别在JavaScript DOM操作中，有两个属性可以获取元素的width属性，但是两者也有很大的不同 style类属性 必须要是行内元素才能获取到，当元素的宽高写在CSS中时，无法获取 获取到的是String，带px 可读写 若没有设置left，style.left返回空字符串 “ “ offset类属性 获取元素的实际存在的宽高，不管是在行内还是页内 获取到的是Number 只可读 offsetWidth(Height)与style.width(height) style中的width与height 不包含边框及内边距 offsetWidth与offsetHeight 获得的数值是元素的宽度+内边距+边框相加 offsetLeft(Top)与style.left(top) style中的left与top 获取的是相对于父对象（具有定位属性 position:relative）的左边距 offsetLeft与Top 获取的是相对于父对象的左边距 offsetParrent与parrentNode offsetParrent 定位定到具有定位属性父元素的 parrentNode 直接定到直系父元素]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的数据类型转换]]></title>
      <url>%2FJavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html</url>
      <content type="text"><![CDATA[Part1 数字转换成字符串1.1 使用JS内部方法进行转换 parseInt 可以将一个字符串型整数进行转换. parseInt提取数字注意点. 第一个字母必须是数字,如果不是数字则显示NaN parseFloat 可以将一个字符串型的浮点数进行转换 因为JS是弱类型语言, 不管是int还是float都是Number. 1.2 直接使用Number对象进行包裹12var a = "10";console.log(Number(a)); 1.3 参与数学计算(加法除外) 加法会将字符串进行拼接 乘法、除法、模运算(取余)都可以将字符串类型变成Number类型. Part2 数字转换成字符串2.1 方法一:直接使用字符串方法 使用数学运算(仅限于加法) 1234var a = 123;console.log(a + "");console.log(typeof (a+ ""));//结果转换成String 使用字符串方法 1234var a = 123;console.log(a.toString());console.log(typeof (a.toString()));//结果转换成String 直接使用String进行包裹 1234var a = 123;console.log(String(a));console.log(typeof (String(a)));//结果转换成String 2.2 方法二:使用小数化方法进行转换 保留三位小数,四舍五入 1234var a = 123.123;console.log(a.toFixed(3));console.log(typeof (a.toFixed(3)));//结果转换成String toFixed: 把数字转换为字符串，结果的小数点后有指定位数的数字。 以指数形式保存 1234var a = 123.123;console.log(a.toExponential(3));console.log(typeof (a.toExponential(3)));//结果转换成String toExponential: 把对象的值转换为指数计数法。 保留三位有效数字,四舍五入 1234var a = 123.123;console.log(a.toPrecision(3));console.log(typeof (a.toPrecision(3)));//结果转换成String toPrecision: 把数字格式化为指定的长度。 Part3 Boolean类型转换 非零即为True 即使是负数 3.1 布尔类型转数字12var isTrue = true;console.log(Number(isTrue)); //1 3.2 布尔类型转字符串12var isTrue = true;console.log(String(isTrue)); //1 3.3 数字转布尔12var age = 13;console.log(Boolean(age)); 3.4 字符串转布尔12345var name = "张三"; //truevar name = " "; //falsevar name = null; //falseconsole.log(Boolean(age));//字符串转布尔需保证有值才为true. 3.5 其他类型转布尔123456var a = NaN; //falsevar b = Infinity; //true,无穷大,非零即为真var c = undefined; //falseconsole.log(Boolean(a));console.log(Boolean(b));console.log(Boolean(c));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS实现常用排序算法]]></title>
      <url>%2FJS%E5%AE%9E%E7%8E%B0%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html</url>
      <content type="text"><![CDATA[插入算法它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。具有n个元素时它需要经过n-1趟排序。对于p = 1到p = n-1趟，插入排序保证从位置0到位置p上的元素为已排序状态。它就是基于这个事实来排序的。123456789101112131415161718function insertionSort(arr)&#123; //如果数组的长度小于等于1，直接返回数组 if (arr.length &lt;= 1) return arr; //遍历数组 for (var i = 0; i &lt; arr.length; i++)&#123; //取到当前数值，往前查找，看时候有比该数值大的数 for(var j = i-1; j &gt;=0; j--)&#123; //如果存在下标小的数大于下标大的数 if (arr[i] &lt; arr[j])&#123; //交换两个数字的位置 var temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125; &#125; return arr;&#125; 最好的情况只需要 n-1 次操作完成，最坏则需要 n(n-1)/2 次。插入算法的时间复杂度为 O(n^2) 。因而插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，插入排序还是一个不错的选择。 冒泡排序冒泡排序与插入排序拥有相等的运行时间。但是两种算法在需要的交换次数却有很大的不同。在最好的情况，冒泡排序需要 O(n^2) 次，而插入排序只要最多 O(n) 次。冒泡排序如果能在内部循环第一次运行时，使用一个 flag 来表示有无交换的可能，也可以把最好的复杂度降低到 O(n) 。在这个情况下，已经排好的数列就无交换的必要了。冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 1234567891011121314151617181920function bubleSort(arr) &#123; //如果数组的长度小于等于1，直接返回数组 if (arr.length &lt;= 1) return arr; var flag = false; //设置 flag 记录是否已经排序完成，降低复杂度 //从第一个数开始遍历数组 for (var i = 0; i &lt; arr.length; i++)&#123; //每完成一次外循环，内循环遍历次数就少一次 for (var j = 0; j &lt; arr.length - i; j++)&#123; //如果前一个数大于后一个数就进行位置交换 if (arr[j] &gt; arr[j+1])&#123; var temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; flag = true; //有交换时 flag 就为true &#125; &#125; //判断是否进行了位置交换，如果没有则排序完成 if (！flag) return arr; &#125;&#125; 选择排序选择排序是一中简单直观的排序算法。它的工作原理如下：首先在未排序序列中找到最小（大）元素，存放到序列的起始位置，然后，再从剩余未排序的元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直至完成排序。选择排序的主要有点与数据移动有关。如果某个元素位于正确的最终位置上，那么它将不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终的位置上，一次对 n 个元素的表进行排序总共进行至多 n-1 次交换。在所有完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。复杂度分析选择排序的交换操作介于 0 和 n-1 次之间。比较操作为 n(n-1)/2 次。赋值操作介于 0 和 3(n-1) 次之间。比较次数时间复杂度为 O(n^2)，标胶次数与关键字的初始状态无关，总次数为 n(n-1)/2 。交换次数 O(n)，最好的情况是已经有序，交换0次，最坏的情况是逆序，交换 n-1 次。交换次数比冒泡排序次数少，由于交换所需 CPU 时间比比较操作所需 CPU 时间多，n 值较小时，选择排序比冒泡排序快。原地操作几乎是选择排序的唯一有点，当空间复杂度要求较高时，可以考虑选择排序，实际适用的场合非常罕见。 123456789101112131415161718function selectionSort(arr) &#123; //如果数组的长度小于等于1，直接返回数组 if (arr.length &lt;= 1) return arr; //遍历数组 for (var i = 0; i &lt; arr.length; i++)&#123; var min = i; //设置已排列序列末尾的下标 //遍历未排列的序列并找出最小值 for (var j = i + 1; j &lt; arr.length; j++) &#123; if(arr[min] &gt; arr[j])&#123; var temp = arr[min] arr[min] = arr[j]; arr[j] = temp; min = j; //更新已排列序列末尾值的下标 &#125; &#125; &#125; return arr;&#125; 快速排序快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。 步骤为： 从数列中挑出一个元素，称为“基准”(pivot) 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆放在基准值后面（相同的数可以在任意一边）。在这个分区结束后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排列。 递归的最底部情形，就是这个数列的长度小于等于1，也就是已经被排好了。虽然一直会递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它的最终位置上。 正如它的名字，快速排序是在时间中最快的已知排序算法，它的时间复杂度为 O(nlogn)。 由于对枢纽元的处理会导致第三步中的分割不为已，因此，我们希望把等于枢纽元的大约一半的关键字分到左边，另外一半分到右边。我们可以采用 Math.floor(arr.length /2) 来得到数组大约一半的这个数值的索引。 123456789101112131415161718192021222324function quickSort(arr) &#123; //如果数组的长度小于等于1，直接返回数组 if (arr.length &lt;= 1) return arr; //获取基准的索引 var pivotIndex = Math.florr(arr.length/2); //将基准数从数组中单独提取出来 var pivot = arr.splice(pivotIndex, 1)[0]; //定义左边和右边两个子序列 var left = []; var right = []; //遍历当前序列 for (var i = 0; i &lt; arr.length; i++)&#123; //如果数值比基准小，放在左边的子序列 if (arr[i] &lt;= pivot)&#123; left.push(arr[i]); &#125; //如果数值比基准大，放在右边的子序列 else&#123; right.push(arr[i]); &#125; &#125; //递归排序 return quickSort(left).concat([pivot], quickSort(right))&#125;]]></content>
    </entry>

    
  
  
</search>
