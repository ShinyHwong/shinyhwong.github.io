<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[值类型与引用类型及在内存中的存储]]></title>
      <url>%2F2017%2F04%2F05%2F%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[全文字数：3450字，阅读时长：8分钟 Part1 值类型与引用类型值类型与引用类型的定义 值类型（基本类型） 定义：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。 5种基本数据类型：string、number 、boolean、null、undefined。 引用类型 定义：存放在堆内存中的对象，变量保存的实际是一个指针，当我们需要访问引用类型时，存放在栈内存中的指针会将我们指向堆内存的数据。每块空间大小不一样，根据情况进行特定的分配。 常见的引用类型有：Array、Object、Function 值类型与引用类型的存储（传值与传址） 值类型的赋值：把右边存储的信息（具体数据）复制一份给左边的变量。 特点：值类型赋值只是简单的数据复制，互相不影响，是独立的。 12345var a = 10;var b = a; //具体数据的复制，复制之后a,b相互独立互不影响b = 1;console.log(a); //10console.log(b); //1 引用类型的赋值：把右边存储的信息（指向具体数据的地址）复制一份给左边的变量。 特点：共享同一份数据，修改其中一个对象属性的值也会影响另一个。 1234567var obj1 = &#123; num : 10 &#125;;var obj2 = obj1; //数据地址的复制，两个对象指向同一份数据，共享同一份数据。obj2.num = 1;console.log(obj1.num); //1 修改obj2的属性也会影响obj1console.log(obj2.num); //1 值类型与引用类型在函数中的应用 在函数中的参数有两种，一种是实参，就是实际的参数。还有一种是形参，形式参数，占位用的，函数调用之前是没有值的。 函数的调用：默认会把实参赋值给形参。 值类型作为函数的参数(值传递) 形参与实参相互独立，没有影响 12345678var num = 10;function fn(n) &#123;//默认会执行一步 n = num； n = 10; console.log(n); //10&#125;fn(num); //函数的调用console.log(num); //20 值传递时，形参实参互不影响 引用类型做为函数的参数(指针传递) 实参形参共享同一份数据，修改一个对象的值也会对另外一个对象产生影响 123456789var obj = &#123;num : 10&#125;; //定义一个对象function fn(object) &#123;//默认进行 object = obj； 此时进行了地址的传递 object.num = 1； //修改了一个源数据，所有指向改数据的对象的属性都进行了更改 object = &#123;other : others&#125;; //object新建一块内存空间，指针指向新建的空间 console.log(object.num); //undefined 新建的空间内部已经没有num属性&#125;fn(obj); //调用函数console.log(obj.num); //1 被object更改了属性 Part2 堆栈的概念堆栈的定义 堆（heap） 动态分配内存，大小不定，不会自动释放存储空间，堆中存储复杂类型数据 栈（stack） 自动分配内存恐怖关键，系统自动释放，栈中存储简单类型数据 栈是一中特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。 后进先出（Last in First out）,简称LIFO线性表 数据在堆栈中的表示JavaScript在内存中是如何表示的呢？我们可以通过以下例子来了解值类型和引用类型在内存中是如何存储的。 123456789101112var zs = &#123; name : 'zs', age : 10, sex : '男', dog : dog, //指向dog对象 run : function () &#123;&#125; //指向run函数&#125;;var dog = &#123; name : '旺财', age : 10, run : function () &#123;&#125; //指向run函数&#125;; 以上代码可以描述为图示的关系： Part3 深拷贝与浅拷贝浅拷贝在定义一个对象或数组的时候，变量在栈中只是存储了一个地址（指针），当我们复制该对象或数组的时候，复制的值也是该地址。在访问属性的时候，还是会通过复制的地址回溯到原来对象或数组指向的内存中。即两者共享了同一内存空间。修改一个对象的属性，另一个对象也会受到影响。1234567function Copy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c; &#125; 深拷贝当我们不希望复制后的对象还与原对象共享同一数据，两者独立时，我们可以使用深拷贝来解决，通过递归的方法，把原对象中的属性方法都遍历给新的对象。这样，两个对象的属性会存储在堆中的不同内存空间。123456789101112131415161718192021function deepClone(obj, copy) &#123; //被拷贝的对象必须是一个对象 copy = copy || &#123;&#125;; //遍历在目标对象中的所有属性 for (var k in obj) &#123; //判断是否是自身的属性，防止遍历到原型属性 if (obj.hasOwnProperty(k)) &#123; //如果是引用类型的属性（function除外）就要进行深拷贝 if (typeof obj[k] === 'object') &#123; //判断属性是数组还是对象 copy[k] = obj[k].constructor === Array ? [] : &#123;&#125;; //递归进更深一层 deepClone(obj[k], copy[k]); &#125; else &#123; //值类型或者是函数直接复制 copy[k] = obj[k]; &#125; &#125; &#125; return copy;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取DOM元素事件位置信息的常用方法]]></title>
      <url>%2F2017%2F04%2F02%2Fclient%E3%80%81offset%E3%80%81screen%E3%80%81page%E3%80%81scroll%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
      <content type="text"><![CDATA[全文字数：3630字，阅读时长：8分钟 在JavaScript的DOM操作中，我们经常需要获取元素或事件的宽高及定位信息。因此我们就需要用到一些属性来得到我们想要的信息。 Part1 client、scroll、offset元素属性的定义在w3c的官方文档里，我们可以看到这几个属性都归类在HTML DOM元素对象的属性方法中，适用于所有HTML元素，都是只读属性。 12345678element.clientHeight //在页面上返回内容的可视高度（不包括边框，边距或滚动条）element.clientLeft //表示一个元素的左边框的宽度,若左边出现了垂直滚动条，也包含滚动条的宽度element.offsetHeight //返回元素的高度，包括边框和填充，但不是边距element.offsetLeft //获取边框相对于具有定位属性的父对象的左边距element.scrollHeight //返回元素的整体高度（包括带滚动条的隐蔽的地方）element.scrollLeft //滚动条卷去隐藏的距离 clientHeight、scrollHeight、offsetHeight的比较clientclientHeight：可见区域的宽度，不包括boder的宽度，如果区域内带有滚动条，还应该减去横向滚动条不可用的高度，正常的是17px，其实就是滚动条的可滚动的部分了，其实clientHeight与height的高度差不多，如果不带滚动条的话他们的值都是一样的，如果带有滚动条的话就会比height值少17px；火狐与IE下均为一致。注意，对于类型&lt;i&gt;,&lt;code&gt;和&lt;span&gt;这些内联元素,clientWidth和clientHeight总是返回0。 scrollscrollHeight：同样不包含border,由height与padding相加。若包含滚动条，scrollHeight就是滚动条可滚动的距离。（height与padding相加在减去滚动条的高度，默认为17px）。直观的说法就是元素的内容区域加上它的内边距再加上任何溢出内容的尺寸。当内容正好和内容区域匹配而没有溢出时，这些属性与clientWidth和clientHeight是相等的。但当溢出时，它们就包含溢出的内容，返回值比clientWidth和clientHeight要大。 offsetoffsetHeight：元素的offsetHeightw值包括该元素的边框,元素的垂直内边距,元素的水平滚动条(若出现水平滚动条),以及元素的样式高度。实际值为height + padding + border。 测试代码123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试代码&lt;/title&gt; &lt;style&gt; div&#123; overflow: scroll; /*设置滚动条*/ position: absolute; left: 1500px; width: 300px; height: 300px; border: 5px solid #000; padding: 10px; margin: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; console.log('clientWidth: '+ div.clientWidth); //320 padding+width 有滚动条时 303 padding+width-scroll(默认17px) console.log('clientLeft: '+ div.clientLeft); //5 边框的宽度，有滚动条就加滚动条宽度 console.log('offsetWidth: '+ div.offsetWidth); //330 boder + padding + width console.log('offsetLeft: '+ div.offsetLeft); //1520 获取边框相对于具有定位属性的父对象的左边距 console.log('scrollWidth: ' + div.scrollWidth); //320 padding + width 有滚动条时 303 padding+width-scrollWidth(默认17px) console.log('scrollLeft: ' + div.scrollLeft); //0 滚动条卷去的部分&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Part2 offset、client、screen、page在DOM事件中的定义在文档中，以上4个属性都归类在DOM Event中，属于事件状态，需要与函数结合起来使用，函数不会在事件发生前执行。常见的事件有鼠标点击、键盘按下等，事件发生后，我们就能检测相应的属性。 screenscreenX:鼠标位置相对于用户屏幕水平偏移量，此时的参照点也就是原点是屏幕的左上角。 clientclientX:跟screenX相比就是将参照点改成了浏览器内容区域的左上角，该参照点会随之滚动条的移动而移动，也就是说，他计算left或top时直接忽略了滚动条的高和宽，它的参考点是浏览器可见区域的左上角，而不是页面本身的body左上角原点，计算数值和滚动条是否滚动没有关系，只是绝对的计算鼠标点距离浏览器内容区域的左上角的距离，忽略了滚动条的存在。 pagepageX：参照点是页面本身的body原点，而不是浏览器内容区域左上角，它计算的值不会随着滚动条而变动，它在计算时其实是以body左上角原点（即页面本身的左上角，而不是浏览器可见区域的左上角）为参考点计算的，这个相当于已经把滚动条滚过的高或宽计算在内了，所以无论滚动条是否滚动，他都是一样的距离值。 pageX = clientX + ScrollLeft(滚动条滚过的水平距离)pageY = clientY + ScrollTop(滚动条滚过的垂直距离) offsetoffsetX：offsetX 表示鼠标指针位置相对于触发事件的对象的 x 坐标。不包含边框，所以可以为负值。 总结在实际开发中，我们经常要使用以上的方法来获得我们需要的值。首先，我们应该注意每一种属性的区别，了解他们是如何计算出来的，不至于在开发中张冠李戴，出现错误。其次，以上各种属性在不同浏览器中也有兼容问题，也是我们必须要要小心的地方，因为你可能写对了名字，但是在这个浏览器中无效，那也是白忙活一场。所以，在开发时，应尽量避免出现这些问题，多进行验证，这样才能保证代码的正确性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[offset类属性与style类属性的区别]]></title>
      <url>%2F2017%2F03%2F21%2Foffset%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8Estyle%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[全文字数：1205字，阅读时长：3分钟 offset类属性与style类属性的区别在JavaScript DOM操作中，有两个属性可以获取元素的width属性，但是两者也有很大的不同 style类属性 必须要是行内元素才能获取到，当元素的宽高写在CSS中时，无法获取 获取到的是String，带px 可读写 若没有设置left，style.left返回空字符串 “ “ offset类属性 获取元素的实际存在的宽高，不管是在行内还是页内 获取到的是Number 只可读 offsetWidth(Height)与style.width(height) style中的width与height 不包含边框及内边距 offsetWidth与offsetHeight 获得的数值是元素的宽度+内边距+边框相加 offsetLeft(Top)与style.left(top) style中的left与top 获取的是相对于父对象（具有定位属性 position:relative）的左边距 offsetLeft与Top 获取的是相对于父对象的左边距 offsetParrent与parrentNode offsetParrent 定位定到具有定位属性父元素的 parrentNode 直接定到直系父元素]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的数据类型转换]]></title>
      <url>%2F2017%2F03%2F14%2FJavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[全文字数：2037字，阅读时长：5分钟 Part1 数字转换成字符串1.1 使用JS内部方法进行转换 parseInt 可以将一个字符串型整数进行转换. parseInt提取数字注意点. 第一个字母必须是数字,如果不是数字则显示NaN parseFloat 可以将一个字符串型的浮点数进行转换 因为JS是弱类型语言, 不管是int还是float都是Number. 1.2 直接使用Number对象进行包裹12var a = "10";console.log(Number(a)); 1.3 参与数学计算(加法除外) 加法会将字符串进行拼接 乘法、除法、模运算(取余)都可以将字符串类型变成Number类型. Part2 数字转换成字符串2.1 方法一:直接使用字符串方法 使用数学运算(仅限于加法) 1234var a = 123;console.log(a + "");console.log(typeof (a+ ""));//结果转换成String 使用字符串方法 1234var a = 123;console.log(a.toString());console.log(typeof (a.toString()));//结果转换成String 直接使用String进行包裹 1234var a = 123;console.log(String(a));console.log(typeof (String(a)));//结果转换成String 2.2 方法二:使用小数化方法进行转换 保留三位小数,四舍五入 1234var a = 123.123;console.log(a.toFixed(3));console.log(typeof (a.toFixed(3)));//结果转换成String toFixed: 把数字转换为字符串，结果的小数点后有指定位数的数字。 以指数形式保存 1234var a = 123.123;console.log(a.toExponential(3));console.log(typeof (a.toExponential(3)));//结果转换成String toExponential: 把对象的值转换为指数计数法。 保留三位有效数字,四舍五入 1234var a = 123.123;console.log(a.toPrecision(3));console.log(typeof (a.toPrecision(3)));//结果转换成String toPrecision: 把数字格式化为指定的长度。 Part3 Boolean类型转换 非零即为True 即使是负数 3.1 布尔类型转数字12var isTrue = true;console.log(Number(isTrue)); //1 3.2 布尔类型转字符串12var isTrue = true;console.log(String(isTrue)); //1 3.3 数字转布尔12var age = 13;console.log(Boolean(age)); 3.4 字符串转布尔12345var name = "张三"; //truevar name = " "; //falsevar name = null; //falseconsole.log(Boolean(age));//字符串转布尔需保证有值才为true. 3.5 其他类型转布尔123456var a = NaN; //falsevar b = Infinity; //true,无穷大,非零即为真var c = undefined; //falseconsole.log(Boolean(a));console.log(Boolean(b));console.log(Boolean(c));]]></content>
    </entry>

    
  
  
</search>
