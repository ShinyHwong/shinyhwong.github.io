<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[构造函数与原型对象]]></title>
      <url>%2F2017%2F04%2F19%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[全文字数：3735字，阅读时长：9分钟 构造函数 函数也可以作为构造函数的参数 构造函数和工厂函数的区别： 构造函数首字母大写 构造函数内部会默认创建新的对象，并且默认返回这个对象 在创建对象的时候，通过new调用构造函数 返回值 构造函数内部没有return，返回默认新创建的对象 如果构造函数内部有return，分两种情况： 返回值类型，忽略该return，返回新创建的对象 返回值是引用类型的数据，会覆盖之前创建的对象，返回该引用类型数据的值1234567function Person(name, age) &#123; this.name = name; this.age = age; //return 'test'; 会忽略该return //return &#123;&#125;; 返回该对象&#125;var p1 = new Person('张三', 20); 实例和实例化使用构造函数创建对象的过程称为实例化，创建出来的这个对象叫做该构造函数的实例。 基本包装类型String、Number、Boolean 可以使用var str = new String(&#39;字符串&#39;)来创建字符串对象，这里typeof str //object var str1 = &#39;字符串&#39;或者var str2 = String(&#39;字符串&#39;)的类型都是string 我们还可以通过 var str = new Object(&#39;字符串&#39;)来创建字符串对象，也可以输入数字或true/false，Object会自动判断是哪种类型。这里typeof str //object 基本数据类型也能有属性或者方法，在内部会进行 创建一个与之对应的对象 利用这个对象访问属性和方法并返回结果 返回结构之后，立即销毁该对象var str = &#39;demo&#39;; console.log(str.length); //4 thisthis指向的是 函数的调用者 或者是 事件的调用者 this -&gt;指向具体的对象函数调用: 作为对象的方法调用 this-&gt;当前的对象 普通函数调用 this-&gt;window 通过new构造函数调用 this-&gt;构造函数内部创建的新对象 使用call / apply调用(函数上下文调用) this-&gt;第一参数 this在事件指令表示事件源this在定时器中表示windows new我们经常利用new运算符去声明新的对象 new运算符接受一个函数F及其参数： new F(arguments…)这一过程分为三步： 创建类的实例。这步是把一个空的对象的__proto__属性设置为F.prototype。 初始化实例。函数F被传入参数并调用，关键字this被设定为该实例。 返回实例，如果没有return，默认返回this引用。 new 运算符的作用是创建一个实例对象。这个对象可以是用户自定义的，也可以是带构造函数的一些系统自带的对象。 new 运算符可以让 this 指向新的对象 所谓“构造函数”，其实就是普通函数内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。为了和普通函数区分， 第一个字母大写 例如：123456789function fun() &#123; alert(this）; //this指向window&#125;fun();function fn() &#123; alert(this）; //this指向fn&#125;new fn(); //添加了new的函数，this指向的是新的对象 私有方法和特权方法私有变量/方法：定义在构造函数内部的变量和方法，私有方法本身是可以访问构造函数内部的所有属性的，即私有属性和共有属性。但是私有方法不可以在构造函数的外部被调用。123456function Fun() &#123; var private = '私有变量'; funciotn privateFun() &#123; console.log('这是一个私有方法'); &#125;&#125; 特权方法：可以当问私有变量和私有函数的实例方法，使用this.来转换。123456789function Fun() &#123; this.name = '名字'; this.showName = funciotn () &#123; //通过this定义一个特权方法 console.log(this.name); &#125;&#125;var obj = new Fun();obj.showName(); //名字 原型对象（prototype） 什么是原型对象？ 在构造函数创建出来的时候，系统会默认创建一个对象和这个构造函数关联，这个对象就称为这个构造函数的原型对象 原型对象的作用？ 使用构造函数创建的对象默认就可以使用原型对象中的属性和方法 怎么访问原型对象？ 构造函数.prototype 对象.__prototype__ 注意：`__prototype__`不是ECMA标准里的属性 怎么设置原型对象？ 原型对象本质也是对象，利用对象的动态特性也可以设置原型对象的属性和方法 使用字面量的方式创建（替换原型） 关于原型对象的替换 替换原型对象之前所创建的对象和替换之后创建的对象，它们的原型对象不是同一个原型对象。（切断） 替换原型对象之后，constructor指向Object，需要在替换时修正构造器的指向 12345678910111213function Person()&#123;&#125; //创建构造函数var p1 = new Person(); //创建对象var obj = &#123; /*修正时需要加一段代码， constructor : Person, 指向原来的原型对象，这样之前创建的对象才能正确使用新的属性方法*/ des : '一段描述'&#125;//替换原型对象Person.prototype = obj;var p2 = new Person();console.log(p1.des); //undefined 替换之前没有des属性console.log(p2.des); //一段描述 原型对象的属性 访问原型对象的属性 对象.属性 构造函数.prototype.属性 属性的访问原则 就近原则： 使用对象.属性访问属性的时候，首先会去找自己身上的属性（实例属性），如果找到就返回该值，如果没有，会去该对象构造函数原型对象上找是否有这个属性（原型属性）。如果都没有，返回undefined或报错(函数)。 设置原型对象的属性 通过构造函数.prototype.属性来设置换着替换原型对象属性 如果属性是引用类型的数据，可以通过实例对象.引用对象.属性的方式修改 关于实例对象中的属性与原型对象中的属性虽然能通过实例对象访问原型对象中的值，但不能通过实例对象重写原型中的值，当为实例对象添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，换句话说，添加的这个属性只会阻止我们访问原型中的那个属性，但不会对原型中属性产生任何影响。不过使用delete操作符可以完全删除实例属性，从而让我们可以重新访问原型中的属性。 属性存在的检测 for..in： 判断对象中是否存在指定的属性。既可以检测实例属性也可以检测原型属性。 hasOwnProperty()方法 ：判断对象中是否存在指定的实例对象中。 补充：对象(Object)数据类型 &gt; 对象就是带有**属性**和**方法**的*数据类型* 例如 `Array`、`Date`等，我们最常用的`Function`也是一个对象，虽然 1typeof function()&#123;&#125;; //"function" 但是Function实例和其他类型的实例没有什么区别，都是对象，只不过`typeof`操作符对其做了特殊处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象基本介绍与创建对象]]></title>
      <url>%2F2017%2F04%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[全文字数：1888字，阅读时长：4分钟 对象（Object）是什么？ 在软件系统中，对象具有唯一的标识符，对象包括属性（Properties）和方法（Methods），属性就是需要记忆的信息，方法就是对象能够提供的服务。在面向对象（Object Oriented）的软件中，对象（Object）是某一个类（Class）的实例（Instance）。 —— 维基百科 面向对象语言的特点：有类(class)的概念，如C++、Java。Javascript没有类的概念，基于原型，支持面向对象。 基本数据类型 string、 number、 boolean、 null、 undefined null、undefined分别表示没有声明和声明后没有初始化的变量、对象，是两个简单的值，其余三个有对应的包装对象Number、Boolean、String 面向对象三大特性 封装 封装就是把过程和数据封闭起来，对数据的访问只能通过开放的接口 作用：方便维护，提高代码的复用性，信息隐蔽 继承 子类对象继成使用父亲的属性和方法 多态 多态是指两个或多个属于不同类的对象，对于同一个消息（方法调用）做出不同响应的方式 Javascript天生就具备多态的特性（弱类型语言） 创建对象 字面量式声明对象 使用场景：只需要简单的创建几个对象 123var obj = &#123; name : 'object'&#125;; 问题：在创建同类型的代码时存在大量重复代码 使用内置的构造函数 系统内置的构造函数: Object、Array、Date、Function等 123var obj = new Object();obj.name = 'object';//等价于 var obj = &#123;&#125;; 问题：复用性不好，存在大量冗余重复代码，与字面量方式类似 简单的工厂的函数 封装：把固定部分写在函数体中，不同的作为函数的参数传递进去 1234567891011//// 01提供函数(工厂函数)封装对象的创建过程function creat(name) &#123; //创建一个空的对象 var obj = new Object(); //设置属性和方法 obj.name = name; //返回对象 return obj;&#125;//创建对象var newObj = creat('objName'); 问题：创建不同类型对象时，无法识别对象 自定义构造函数创建对象 提供一个构造函数 通过this设置属性和方法 使用new构造函数创建对象 12345678910111213function Person(name, age) &#123; /* 默认会创建一个新的对象 var obj = new Object(); 默认会把新创建的对象赋值给this this = obj; */ this.name = name; this.age = age; /*默认会返回新创建的对象 return this;*/&#125;var p1 = new Person('张三', 20); 问题：破坏封装性，结构性不好，全局变量污染。创建多个对象时，内部属性方法一样，每次都会开辟一块新的内存空间，造成浪费解决办法：通过原型属性和方法 判断对象的类型 instanceof ：判断某一变量是否为一个对象的实例 用法：判断a是否是A的一个实例，a instanceof A；返回boolean isPropertyOf：判断一个对象是否是指定对象的原型对象 用法：判断object是否是obj的原型对象，object.isPropertyOf(obj); 返回boolean constructor ：构造器属性，获取对象是由哪一个构造函数所创建的 用法：获得实例对象a的构造函数 a.constructor; 返回a的构造函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[值类型与引用类型及在内存中的存储]]></title>
      <url>%2F2017%2F04%2F05%2F%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[全文字数：3450字，阅读时长：8分钟 Part1 值类型与引用类型值类型与引用类型的定义 值类型（基本类型） 定义：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。 5种基本数据类型：string、number 、boolean、null、undefined。 引用类型 定义：存放在堆内存中的对象，变量保存的实际是一个指针，当我们需要访问引用类型时，存放在栈内存中的指针会将我们指向堆内存的数据。每块空间大小不一样，根据情况进行特定的分配。 常见的引用类型有：Array、Object、Function 值类型与引用类型的存储（传值与传址） 值类型的赋值：把右边存储的信息（具体数据）复制一份给左边的变量。 特点：值类型赋值只是简单的数据复制，互相不影响，是独立的。 12345var a = 10;var b = a; //具体数据的复制，复制之后a,b相互独立互不影响b = 1;console.log(a); //10console.log(b); //1 引用类型的赋值：把右边存储的信息（指向具体数据的地址）复制一份给左边的变量。 特点：共享同一份数据，修改其中一个对象属性的值也会影响另一个。 1234567var obj1 = &#123; num : 10 &#125;;var obj2 = obj1; //数据地址的复制，两个对象指向同一份数据，共享同一份数据。obj2.num = 1;console.log(obj1.num); //1 修改obj2的属性也会影响obj1console.log(obj2.num); //1 值类型与引用类型在函数中的应用 在函数中的参数有两种，一种是实参，就是实际的参数。还有一种是形参，形式参数，占位用的，函数调用之前是没有值的。 函数的调用：默认会把实参赋值给形参。 值类型作为函数的参数(值传递) 形参与实参相互独立，没有影响 12345678var num = 10;function fn(n) &#123;//默认会执行一步 n = num； n = 10; console.log(n); //10&#125;fn(num); //函数的调用console.log(num); //20 值传递时，形参实参互不影响 引用类型做为函数的参数(指针传递) 实参形参共享同一份数据，修改一个对象的值也会对另外一个对象产生影响 123456789var obj = &#123;num : 10&#125;; //定义一个对象function fn(object) &#123;//默认进行 object = obj； 此时进行了地址的传递 object.num = 1； //修改了一个源数据，所有指向改数据的对象的属性都进行了更改 object = &#123;other : others&#125;; //object新建一块内存空间，指针指向新建的空间 console.log(object.num); //undefined 新建的空间内部已经没有num属性&#125;fn(obj); //调用函数console.log(obj.num); //1 被object更改了属性 Part2 堆栈的概念堆栈的定义 堆（heap） 动态分配内存，大小不定，不会自动释放存储空间，堆中存储复杂类型数据 栈（stack） 自动分配内存恐怖关键，系统自动释放，栈中存储简单类型数据 栈是一中特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。 后进先出（Last in First out）,简称LIFO线性表 数据在堆栈中的表示JavaScript在内存中是如何表示的呢？我们可以通过以下例子来了解值类型和引用类型在内存中是如何存储的。 123456789101112var zs = &#123; name : 'zs', age : 10, sex : '男', dog : dog, //指向dog对象 run : function () &#123;&#125; //指向run函数&#125;;var dog = &#123; name : '旺财', age : 10, run : function () &#123;&#125; //指向run函数&#125;; 以上代码可以描述为图示的关系： Part3 深拷贝与浅拷贝浅拷贝在定义一个对象或数组的时候，变量在栈中只是存储了一个地址（指针），当我们复制该对象或数组的时候，复制的值也是该地址。在访问属性的时候，还是会通过复制的地址回溯到原来对象或数组指向的内存中。即两者共享了同一内存空间。修改一个对象的属性，另一个对象也会受到影响。1234567function Copy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c; &#125; 深拷贝当我们不希望复制后的对象还与原对象共享同一数据，两者独立时，我们可以使用深拷贝来解决，通过递归的方法，把原对象中的属性方法都遍历给新的对象。这样，两个对象的属性会存储在堆中的不同内存空间。123456789101112131415161718192021function deepClone(obj, copy) &#123; //被拷贝的对象必须是一个对象 copy = copy || &#123;&#125;; //遍历在目标对象中的所有属性 for (var k in obj) &#123; //判断是否是自身的属性，防止遍历到原型属性 if (obj.hasOwnProperty(k)) &#123; //如果是引用类型的属性（function除外）就要进行深拷贝 if (typeof obj[k] === 'object') &#123; //判断属性是数组还是对象 copy[k] = obj[k].constructor === Array ? [] : &#123;&#125;; //递归进更深一层 deepClone(obj[k], copy[k]); &#125; else &#123; //值类型或者是函数直接复制 copy[k] = obj[k]; &#125; &#125; &#125; return copy;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取DOM元素事件位置信息的常用方法]]></title>
      <url>%2F2017%2F04%2F02%2Fclient%E3%80%81offset%E3%80%81screen%E3%80%81page%E3%80%81scroll%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
      <content type="text"><![CDATA[全文字数：3630字，阅读时长：8分钟 在JavaScript的DOM操作中，我们经常需要获取元素或事件的宽高及定位信息。因此我们就需要用到一些属性来得到我们想要的信息。 Part1 client、scroll、offset元素属性的定义在w3c的官方文档里，我们可以看到这几个属性都归类在HTML DOM元素对象的属性方法中，适用于所有HTML元素，都是只读属性。 12345678element.clientHeight //在页面上返回内容的可视高度（不包括边框，边距或滚动条）element.clientLeft //元素的左边框的宽度,若左边出现了垂直滚动条，也包含滚动条的宽度element.offsetHeight //返回元素的高度，包括边框和填充，但不是边距element.offsetLeft //获取边框相对于具有定位属性的父对象的左边距element.scrollHeight //返回元素的整体高度（包括带滚动条的隐蔽的地方）element.scrollLeft //滚动条卷去隐藏的距离 clientHeight、scrollHeight、offsetHeight的比较clientclientHeight：可见区域的宽度，不包括boder的宽度，如果区域内带有滚动条，还应该减去横向滚动条不可用的高度，正常的是17px，其实就是滚动条的可滚动的部分了，其实clientHeight与height的高度差不多，如果不带滚动条的话他们的值都是一样的，如果带有滚动条的话就会比height值少17px；火狐与IE下均为一致。注意，对于类型&lt;i&gt;,&lt;code&gt;和&lt;span&gt;这些内联元素,clientWidth和clientHeight总是返回0。 scrollscrollHeight：同样不包含border,由height与padding相加。若包含滚动条，scrollHeight就是滚动条可滚动的距离。（height与padding相加在减去滚动条的高度，默认为17px）。直观的说法就是元素的内容区域加上它的内边距再加上任何溢出内容的尺寸。当内容正好和内容区域匹配而没有溢出时，这些属性与clientWidth和clientHeight是相等的。但当溢出时，它们就包含溢出的内容，返回值比clientWidth和clientHeight要大。 offsetoffsetHeight：元素的offsetHeightw值包括该元素的边框,元素的垂直内边距,元素的水平滚动条(若出现水平滚动条),以及元素的样式高度。实际值为height + padding + border。 测试代码123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试代码&lt;/title&gt; &lt;style&gt; div&#123; overflow: scroll; /*设置滚动条*/ position: absolute; left: 1500px; width: 300px; height: 300px; border: 5px solid #000; padding: 10px; margin: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; console.log('clientWidth: '+ div.clientWidth); //320 padding+width 有滚动条时 303 padding+width-scroll(默认17px) console.log('clientLeft: '+ div.clientLeft); //5 边框的宽度，有滚动条就加滚动条宽度 console.log('offsetWidth: '+ div.offsetWidth); //330 boder + padding + width console.log('offsetLeft: '+ div.offsetLeft); //1520 获取边框相对于具有定位属性的父对象的左边距 console.log('scrollWidth: ' + div.scrollWidth); //320 padding + width 有滚动条时 303 padding+width-scrollWidth(默认17px) console.log('scrollLeft: ' + div.scrollLeft); //0 滚动条卷去的部分&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Part2 offset、client、screen、page在DOM事件中的定义在文档中，以上4个属性都归类在DOM Event中，属于事件状态，需要与函数结合起来使用，函数不会在事件发生前执行。常见的事件有鼠标点击、键盘按下等，事件发生后，我们就能检测相应的属性。 screenscreenX:鼠标位置相对于用户屏幕水平偏移量，此时的参照点也就是原点是屏幕的左上角。 clientclientX:跟screenX相比就是将参照点改成了浏览器内容区域的左上角，该参照点会随之滚动条的移动而移动，也就是说，他计算left或top时直接忽略了滚动条的高和宽，它的参考点是浏览器可见区域的左上角，而不是页面本身的body左上角原点，计算数值和滚动条是否滚动没有关系，只是绝对的计算鼠标点距离浏览器内容区域的左上角的距离，忽略了滚动条的存在。 pagepageX：参照点是页面本身的body原点，而不是浏览器内容区域左上角，它计算的值不会随着滚动条而变动，它在计算时其实是以body左上角原点（即页面本身的左上角，而不是浏览器可见区域的左上角）为参考点计算的，这个相当于已经把滚动条滚过的高或宽计算在内了，所以无论滚动条是否滚动，他都是一样的距离值。 pageX = clientX + ScrollLeft(滚动条滚过的水平距离)pageY = clientY + ScrollTop(滚动条滚过的垂直距离) offsetoffsetX：offsetX 表示鼠标指针位置相对于触发事件的对象的 x 坐标。不包含边框，所以可以为负值。 总结在实际开发中，我们经常要使用以上的方法来获得我们需要的值。首先，我们应该注意每一种属性的区别，了解他们是如何计算出来的，不至于在开发中张冠李戴，出现错误。其次，以上各种属性在不同浏览器中也有兼容问题，也是我们必须要要小心的地方，因为你可能写对了名字，但是在这个浏览器中无效，那也是白忙活一场。所以，在开发时，应尽量避免出现这些问题，多进行验证，这样才能保证代码的正确性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[offset类属性与style类属性的区别]]></title>
      <url>%2F2017%2F03%2F21%2Foffset%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8Estyle%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[全文字数：1115字，阅读时长：3分钟 offset类属性与style类属性的区别在JavaScript DOM操作中，有两个属性可以获取元素的width属性，但是两者也有很大的不同 style类属性 必须要是行内元素才能获取到，当元素的宽高写在CSS中时，无法获取 获取到的是String，带px 可读写 若没有设置left，style.left返回空字符串 “ “ offset类属性 获取元素的实际存在的宽高，不管是在行内还是页内 获取到的是Number 只可读 offsetWidth(Height)与style.width(height) style中的width与height 不包含边框及内边距 offsetWidth与offsetHeight 获得的数值是元素的宽度+内边距+边框相加 offsetLeft(Top)与style.left(top) style中的left与top 获取的是相对于父对象（具有定位属性 position:relative）的左边距 offsetLeft与Top 获取的是相对于父对象的左边距 offsetParrent与parrentNode offsetParrent 定位定到具有定位属性父元素的 parrentNode 直接定到直系父元素]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的数据类型转换]]></title>
      <url>%2F2017%2F03%2F14%2FJavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[全文字数：2037字，阅读时长：5分钟 Part1 数字转换成字符串1.1 使用JS内部方法进行转换 parseInt 可以将一个字符串型整数进行转换. parseInt提取数字注意点. 第一个字母必须是数字,如果不是数字则显示NaN parseFloat 可以将一个字符串型的浮点数进行转换 因为JS是弱类型语言, 不管是int还是float都是Number. 1.2 直接使用Number对象进行包裹12var a = "10";console.log(Number(a)); 1.3 参与数学计算(加法除外) 加法会将字符串进行拼接 乘法、除法、模运算(取余)都可以将字符串类型变成Number类型. Part2 数字转换成字符串2.1 方法一:直接使用字符串方法 使用数学运算(仅限于加法) 1234var a = 123;console.log(a + "");console.log(typeof (a+ ""));//结果转换成String 使用字符串方法 1234var a = 123;console.log(a.toString());console.log(typeof (a.toString()));//结果转换成String 直接使用String进行包裹 1234var a = 123;console.log(String(a));console.log(typeof (String(a)));//结果转换成String 2.2 方法二:使用小数化方法进行转换 保留三位小数,四舍五入 1234var a = 123.123;console.log(a.toFixed(3));console.log(typeof (a.toFixed(3)));//结果转换成String toFixed: 把数字转换为字符串，结果的小数点后有指定位数的数字。 以指数形式保存 1234var a = 123.123;console.log(a.toExponential(3));console.log(typeof (a.toExponential(3)));//结果转换成String toExponential: 把对象的值转换为指数计数法。 保留三位有效数字,四舍五入 1234var a = 123.123;console.log(a.toPrecision(3));console.log(typeof (a.toPrecision(3)));//结果转换成String toPrecision: 把数字格式化为指定的长度。 Part3 Boolean类型转换 非零即为True 即使是负数 3.1 布尔类型转数字12var isTrue = true;console.log(Number(isTrue)); //1 3.2 布尔类型转字符串12var isTrue = true;console.log(String(isTrue)); //1 3.3 数字转布尔12var age = 13;console.log(Boolean(age)); 3.4 字符串转布尔12345var name = "张三"; //truevar name = " "; //falsevar name = null; //falseconsole.log(Boolean(age));//字符串转布尔需保证有值才为true. 3.5 其他类型转布尔123456var a = NaN; //falsevar b = Infinity; //true,无穷大,非零即为真var c = undefined; //falseconsole.log(Boolean(a));console.log(Boolean(b));console.log(Boolean(c));]]></content>
    </entry>

    
  
  
</search>
